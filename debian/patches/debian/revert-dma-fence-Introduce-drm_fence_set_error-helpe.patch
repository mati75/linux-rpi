From 2eac1dd4de9fdeb3591cc0b38b700f49ddd34275 Mon Sep 17 00:00:00 2001
From: Yves-Alexis Perez <corsac@debian.org>
Date: Sun, 7 Jan 2018 13:36:38 +0100
Subject: [PATCH] Revert "dma-fence: Introduce drm_fence_set_error() helper"

This reverts commit f5e0724e76c2c8efb4d3dc43c24228b409bbbfe9 (commit
a009e975da5c7d42a7f5eaadc54946eb5f76c9af) which changes a field inside
the struct fence.
---
 drivers/dma-buf/fence.c |  2 +-
 include/linux/fence.h   | 30 +++++-------------------------
 2 files changed, 6 insertions(+), 26 deletions(-)

diff --git a/drivers/dma-buf/fence.c b/drivers/dma-buf/fence.c
index 04bf29808200..c7a0eefb93ab 100644
--- a/drivers/dma-buf/fence.c
+++ b/drivers/dma-buf/fence.c
@@ -551,7 +551,7 @@ fence_init(struct fence *fence, const struct fence_ops *ops,
 	fence->context = context;
 	fence->seqno = seqno;
 	fence->flags = 0UL;
-	fence->error = 0;
+	fence->status = 0;
 
 	trace_fence_init(fence);
 }
diff --git a/include/linux/fence.h b/include/linux/fence.h
index 9bb2c0c97a21..2dfed6957b61 100644
--- a/include/linux/fence.h
+++ b/include/linux/fence.h
@@ -47,7 +47,7 @@ struct fence_cb;
  * can be compared to decide which fence would be signaled later.
  * @flags: A mask of FENCE_FLAG_* defined below
  * @timestamp: Timestamp when the fence was signaled.
- * @error: Optional, only valid if < 0, must be set before calling
+ * @status: Optional, only valid if < 0, must be set before calling
  * fence_signal, indicates that the fence has completed with an error.
  *
  * the flags member must be manipulated and read using the appropriate
@@ -79,7 +79,7 @@ struct fence {
 	unsigned seqno;
 	unsigned long flags;
 	ktime_t timestamp;
-	int error;
+	int status;
 };
 
 enum fence_flag_bits {
@@ -132,7 +132,7 @@ struct fence_cb {
  * or some failure occurred that made it impossible to enable
  * signaling. True indicates successful enabling.
  *
- * fence->error may be set in enable_signaling, but only when false is
+ * fence->status may be set in enable_signaling, but only when false is
  * returned.
  *
  * Calling fence_signal before enable_signaling is called allows
@@ -144,7 +144,7 @@ struct fence_cb {
  * the second time will be a noop since it was already signaled.
  *
  * Notes on signaled:
- * May set fence->error if returning true.
+ * May set fence->status if returning true.
  *
  * Notes on wait:
  * Must not be NULL, set to fence_default_wait for default implementation.
@@ -351,33 +351,13 @@ static inline struct fence *fence_later(struct fence *f1, struct fence *f2)
 static inline int fence_get_status_locked(struct fence *fence)
 {
 	if (fence_is_signaled_locked(fence))
-		return fence->error ?: 1;
+		return fence->status < 0 ? fence->status : 1;
 	else
 		return 0;
 }
 
 int fence_get_status(struct fence *fence);
 
-/**
- * fence_set_error - flag an error condition on the fence
- * @fence: [in]	the fence
- * @error: [in]	the error to store
- *
- * Drivers can supply an optional error status condition before they signal
- * the fence, to indicate that the fence was completed due to an error
- * rather than success. This must be set before signaling (so that the value
- * is visible before any waiters on the signal callback are woken). This
- * helper exists to help catching erroneous setting of #fence.error.
- */
-static inline void fence_set_error(struct fence *fence,
-				       int error)
-{
-	BUG_ON(test_bit(FENCE_FLAG_SIGNALED_BIT, &fence->flags));
-	BUG_ON(error >= 0 || error < -MAX_ERRNO);
-
-	fence->error = error;
-}
-
 signed long fence_wait_timeout(struct fence *, bool intr, signed long timeout);
 signed long fence_wait_any_timeout(struct fence **fences, uint32_t count,
 				   bool intr, signed long timeout);
-- 
2.15.1

