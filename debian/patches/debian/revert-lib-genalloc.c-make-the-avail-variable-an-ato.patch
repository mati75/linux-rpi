From 59c408f070056ac46a30b3ef91e92acf6e25fba7 Mon Sep 17 00:00:00 2001
From: Yves-Alexis Perez <corsac@debian.org>
Date: Sat, 6 Jan 2018 21:47:10 +0100
Subject: [PATCH] Revert "lib/genalloc.c: make the avail variable an atomic_long_t"
Forwarded: not-needed

This reverts commit a77c116075936faa6e8b8622e22acc9cbf47fe9e which is
commit 36a3d1dd4e16bcd0d2ddfb4a2ec7092f0ae0d931 upsream. It converts the
`avail' field in struct gen_pool_chunk' to an atomic_long, causing an
ABI breaks.
---
 include/linux/genalloc.h |  3 +--
 lib/genalloc.c           | 10 +++++-----
 2 files changed, 6 insertions(+), 7 deletions(-)

diff --git a/include/linux/genalloc.h b/include/linux/genalloc.h
index 206fe3bccccc..29d4385903d4 100644
--- a/include/linux/genalloc.h
+++ b/include/linux/genalloc.h
@@ -32,7 +32,6 @@
 
 #include <linux/types.h>
 #include <linux/spinlock_types.h>
-#include <linux/atomic.h>
 
 struct device;
 struct device_node;
@@ -71,7 +70,7 @@ struct gen_pool {
  */
 struct gen_pool_chunk {
 	struct list_head next_chunk;	/* next chunk in pool */
-	atomic_long_t avail;
+	atomic_t avail;
 	phys_addr_t phys_addr;		/* physical starting address of memory chunk */
 	unsigned long start_addr;	/* start address of memory chunk */
 	unsigned long end_addr;		/* end address of memory chunk (inclusive) */
diff --git a/lib/genalloc.c b/lib/genalloc.c
index ca06adc4f445..144fe6b1a03e 100644
--- a/lib/genalloc.c
+++ b/lib/genalloc.c
@@ -194,7 +194,7 @@ int gen_pool_add_virt(struct gen_pool *pool, unsigned long virt, phys_addr_t phy
 	chunk->phys_addr = phys;
 	chunk->start_addr = virt;
 	chunk->end_addr = virt + size - 1;
-	atomic_long_set(&chunk->avail, size);
+	atomic_set(&chunk->avail, size);
 
 	spin_lock(&pool->lock);
 	list_add_rcu(&chunk->next_chunk, &pool->chunks);
@@ -304,7 +304,7 @@ unsigned long gen_pool_alloc_algo(struct gen_pool *pool, size_t size,
 	nbits = (size + (1UL << order) - 1) >> order;
 	rcu_read_lock();
 	list_for_each_entry_rcu(chunk, &pool->chunks, next_chunk) {
-		if (size > atomic_long_read(&chunk->avail))
+		if (size > atomic_read(&chunk->avail))
 			continue;
 
 		start_bit = 0;
@@ -324,7 +324,7 @@ unsigned long gen_pool_alloc_algo(struct gen_pool *pool, size_t size,
 
 		addr = chunk->start_addr + ((unsigned long)start_bit << order);
 		size = nbits << order;
-		atomic_long_sub(size, &chunk->avail);
+		atomic_sub(size, &chunk->avail);
 		break;
 	}
 	rcu_read_unlock();
@@ -390,7 +390,7 @@ void gen_pool_free(struct gen_pool *pool, unsigned long addr, size_t size)
 			remain = bitmap_clear_ll(chunk->bits, start_bit, nbits);
 			BUG_ON(remain);
 			size = nbits << order;
-			atomic_long_add(size, &chunk->avail);
+			atomic_add(size, &chunk->avail);
 			rcu_read_unlock();
 			return;
 		}
@@ -464,7 +464,7 @@ size_t gen_pool_avail(struct gen_pool *pool)
 
 	rcu_read_lock();
 	list_for_each_entry_rcu(chunk, &pool->chunks, next_chunk)
-		avail += atomic_long_read(&chunk->avail);
+		avail += atomic_read(&chunk->avail);
 	rcu_read_unlock();
 	return avail;
 }
-- 
2.15.1

