commit 440ea29af6a59c80f1bb76d1dbabf49e85ffd9a7
Author: Xin Long <lucien.xin@gmail.com>
Date:   Sat Aug 26 20:10:10 2017 +0800

    ipv6: set dst.obsolete when a cached route has expired
    
    
    [ Upstream commit 1e2ea8ad37be25a7cdcc974945935829d534d5d3 ]
    
    Now it doesn't check for the cached route expiration in ipv6's
    dst_ops->check(), because it trusts dst_gc that would clean the
    cached route up when it's expired.
    
    The problem is in dst_gc, it would clean the cached route only
    when it's refcount is 1. If some other module (like xfrm) keeps
    holding it and the module only release it when dst_ops->check()
    fails.
    
    But without checking for the cached route expiration, .check()
    may always return true. Meanwhile, without releasing the cached
    route, dst_gc couldn't del it. It will cause this cached route
    never to expire.
    
    This patch is to set dst.obsolete with DST_OBSOLETE_KILL in .gc
    when it's expired, and check obsolete != DST_OBSOLETE_FORCE_CHK
    in .check.
    
    Note that this is even needed when ipv6 dst_gc timer is removed
    one day. It would set dst.obsolete in .redirect and .update_pmtu
    instead, and check for cached route expiration when getting it,
    just like what ipv4 route does.
    
    Reported-by: Jianlin Shi <jishi@redhat.com>
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Acked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/net/ipv6/ip6_fib.c b/net/ipv6/ip6_fib.c
index 846648ea3bcc..76cdaa9d4a51 100644
--- a/net/ipv6/ip6_fib.c
+++ b/net/ipv6/ip6_fib.c
@@ -1790,8 +1790,10 @@ static int fib6_age(struct rt6_info *rt, void *arg)
 		}
 		gc_args->more++;
 	} else if (rt->rt6i_flags & RTF_CACHE) {
+		if (time_after_eq(now, rt->dst.lastuse + gc_args->timeout))
+			rt->dst.obsolete = DST_OBSOLETE_KILL;
 		if (atomic_read(&rt->dst.__refcnt) == 0 &&
-		    time_after_eq(now, rt->dst.lastuse + gc_args->timeout)) {
+		    rt->dst.obsolete == DST_OBSOLETE_KILL) {
 			RT6_TRACE("aging clone %p\n", rt);
 			return -1;
 		} else if (rt->rt6i_flags & RTF_GATEWAY) {
diff --git a/net/ipv6/route.c b/net/ipv6/route.c
index cd2fb18d9f8d..b75f79a07962 100644
--- a/net/ipv6/route.c
+++ b/net/ipv6/route.c
@@ -444,7 +444,8 @@ static bool rt6_check_expired(const struct rt6_info *rt)
 		if (time_after(jiffies, rt->dst.expires))
 			return true;
 	} else if (rt->dst.from) {
-		return rt6_check_expired((struct rt6_info *) rt->dst.from);
+		return rt->dst.obsolete != DST_OBSOLETE_FORCE_CHK ||
+		       rt6_check_expired((struct rt6_info *)rt->dst.from);
 	}
 	return false;
 }
diff -uN a/1.txt b/1.txt
--- a/dummy/rpi_1017_440ea29af6a59c80f1bb76d1dbabf49e85ffd9a7.txt	1970-01-01 00:00:00.000000000 +0000
+++ b/dummy/rpi_1017_440ea29af6a59c80f1bb76d1dbabf49e85ffd9a7.txt	2013-12-23 04:07:40.000000000 +0000
@@ -0,0 +1 @@
+dummy file to ensure patch has content.
