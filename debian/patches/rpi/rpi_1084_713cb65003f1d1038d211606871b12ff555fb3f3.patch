commit 713cb65003f1d1038d211606871b12ff555fb3f3
Author: Ross Zwisler <ross.zwisler@linux.intel.com>
Date:   Thu Oct 12 11:52:34 2017 -0400

    ext4: prevent data corruption with inline data + DAX
    
    commit 559db4c6d784ceedc2a5418ced4d357cb843e221 upstream.
    
    If an inode has inline data it is currently prevented from using DAX by a
    check in ext4_set_inode_flags().  When the inode grows inline data via
    ext4_create_inline_data() or removes its inline data via
    ext4_destroy_inline_data_nolock(), the value of S_DAX can change.
    
    Currently these changes are unsafe because we don't hold off page faults
    and I/O, write back dirty radix tree entries and invalidate all mappings.
    There are also issues with mm-level races when changing the value of S_DAX,
    as well as issues with the VM_MIXEDMAP flag:
    
    https://www.spinics.net/lists/linux-xfs/msg09859.html
    
    The unsafe transition of S_DAX can reliably cause data corruption, as shown
    by the following fstest:
    
    https://patchwork.kernel.org/patch/9948381/
    
    Fix this issue by preventing the DAX mount option from being used on
    filesystems that were created to support inline data.  Inline data is an
    option given to mkfs.ext4.
    
    Signed-off-by: Ross Zwisler <ross.zwisler@linux.intel.com>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/ext4/inline.c b/fs/ext4/inline.c
index 28c5c3abddb3..fd9501977f1c 100644
--- a/fs/ext4/inline.c
+++ b/fs/ext4/inline.c
@@ -302,11 +302,6 @@ static int ext4_create_inline_data(handle_t *handle,
 	EXT4_I(inode)->i_inline_size = len + EXT4_MIN_INLINE_DATA_SIZE;
 	ext4_clear_inode_flag(inode, EXT4_INODE_EXTENTS);
 	ext4_set_inode_flag(inode, EXT4_INODE_INLINE_DATA);
-	/*
-	 * Propagate changes to inode->i_flags as well - e.g. S_DAX may
-	 * get cleared
-	 */
-	ext4_set_inode_flags(inode);
 	get_bh(is.iloc.bh);
 	error = ext4_mark_iloc_dirty(handle, inode, &is.iloc);
 
@@ -451,11 +446,6 @@ static int ext4_destroy_inline_data_nolock(handle_t *handle,
 		}
 	}
 	ext4_clear_inode_flag(inode, EXT4_INODE_INLINE_DATA);
-	/*
-	 * Propagate changes to inode->i_flags as well - e.g. S_DAX may
-	 * get set.
-	 */
-	ext4_set_inode_flags(inode);
 
 	get_bh(is.iloc.bh);
 	error = ext4_mark_iloc_dirty(handle, inode, &is.iloc);
diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index b0915b734a38..f29351c66610 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -3708,6 +3708,11 @@ static int ext4_fill_super(struct super_block *sb, void *data, int silent)
 	}
 
 	if (sbi->s_mount_opt & EXT4_MOUNT_DAX) {
+		if (ext4_has_feature_inline_data(sb)) {
+			ext4_msg(sb, KERN_ERR, "Cannot use DAX on a filesystem"
+					" that may contain inline data");
+			goto failed_mount;
+		}
 		err = bdev_dax_supported(sb, blocksize);
 		if (err)
 			goto failed_mount;
diff -uN a/1.txt b/1.txt
--- a/dummy/rpi_1084_713cb65003f1d1038d211606871b12ff555fb3f3.txt	1970-01-01 00:00:00.000000000 +0000
+++ b/dummy/rpi_1084_713cb65003f1d1038d211606871b12ff555fb3f3.txt	2013-12-23 04:07:40.000000000 +0000
@@ -0,0 +1 @@
+dummy file to ensure patch has content.
