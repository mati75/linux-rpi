commit c6f27cdd4fca48d945a8896f8902e7cb0692a7a6
Author: Sudeep Holla <sudeep.holla@arm.com>
Date:   Mon Jan 7 18:51:53 2019 +0000

    cpufreq: check if policy is inactive early in __cpufreq_get()
    
    [ Upstream commit 2f66196208c98b3d1b4294edffb2c5a8197be899 ]
    
    cpuinfo_cur_freq gets current CPU frequency as detected by hardware
    while scaling_cur_freq last known CPU frequency. Some platforms may not
    allow checking the CPU frequency of an offline CPU or the associated
    resources may have been released via cpufreq_exit when the CPU gets
    offlined, in which case the policy would have been invalidated already.
    If we attempt to get current frequency from the hardware, it may result
    in hang or crash.
    
    For example on Juno, I see:
    
    Unable to handle kernel NULL pointer dereference at virtual address 0000000000000188
    [0000000000000188] pgd=0000000000000000
    Internal error: Oops: 96000004 [#1] PREEMPT SMP
    Modules linked in:
    CPU: 5 PID: 4202 Comm: cat Not tainted 4.20.0-08251-ga0f2c0318a15-dirty #87
    Hardware name: ARM LTD ARM Juno Development Platform/ARM Juno Development Platform
    pstate: 40000005 (nZcv daif -PAN -UAO)
    pc : scmi_cpufreq_get_rate+0x34/0xb0
    lr : scmi_cpufreq_get_rate+0x34/0xb0
    Call trace:
     scmi_cpufreq_get_rate+0x34/0xb0
     __cpufreq_get+0x34/0xc0
     show_cpuinfo_cur_freq+0x24/0x78
     show+0x40/0x60
     sysfs_kf_seq_show+0xc0/0x148
     kernfs_seq_show+0x44/0x50
     seq_read+0xd4/0x480
     kernfs_fop_read+0x15c/0x208
     __vfs_read+0x60/0x188
     vfs_read+0x94/0x150
     ksys_read+0x6c/0xd8
     __arm64_sys_read+0x24/0x30
     el0_svc_common+0x78/0x100
     el0_svc_handler+0x38/0x78
     el0_svc+0x8/0xc
    ---[ end trace 3d1024e58f77f6b2 ]---
    
    So fix the issue by checking if the policy is invalid early in
    __cpufreq_get before attempting to get the current frequency.
    
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    
    Signed-off-by: Sasha Levin <sashal@kernel.org>

diff --git a/drivers/cpufreq/cpufreq.c b/drivers/cpufreq/cpufreq.c
index f53fb41efb7b..b100260b6ed2 100644
--- a/drivers/cpufreq/cpufreq.c
+++ b/drivers/cpufreq/cpufreq.c
@@ -1530,17 +1530,16 @@ static unsigned int __cpufreq_get(struct cpufreq_policy *policy)
 {
 	unsigned int ret_freq = 0;
 
-	if (!cpufreq_driver->get)
+	if (unlikely(policy_is_inactive(policy)) || !cpufreq_driver->get)
 		return ret_freq;
 
 	ret_freq = cpufreq_driver->get(policy->cpu);
 
 	/*
-	 * Updating inactive policies is invalid, so avoid doing that.  Also
-	 * if fast frequency switching is used with the given policy, the check
+	 * If fast frequency switching is used with the given policy, the check
 	 * against policy->cur is pointless, so skip it in that case too.
 	 */
-	if (unlikely(policy_is_inactive(policy)) || policy->fast_switch_enabled)
+	if (policy->fast_switch_enabled)
 		return ret_freq;
 
 	if (ret_freq && policy->cur &&
@@ -1569,10 +1568,7 @@ unsigned int cpufreq_get(unsigned int cpu)
 
 	if (policy) {
 		down_read(&policy->rwsem);
-
-		if (!policy_is_inactive(policy))
-			ret_freq = __cpufreq_get(policy);
-
+		ret_freq = __cpufreq_get(policy);
 		up_read(&policy->rwsem);
 
 		cpufreq_cpu_put(policy);
diff -uN a/1.txt b/1.txt
--- a/dummy/rpi_1381_c6f27cdd4fca48d945a8896f8902e7cb0692a7a6.txt	1970-01-01 00:00:00.000000000 +0000
+++ b/dummy/rpi_1381_c6f27cdd4fca48d945a8896f8902e7cb0692a7a6.txt	2013-12-23 04:07:40.000000000 +0000
@@ -0,0 +1 @@
+dummy file to ensure patch has content.
