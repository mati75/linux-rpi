commit f725c58799604308406e169b98e9e3955a97efae
Author: Xin Long <lucien.xin@gmail.com>
Date:   Thu Aug 3 14:13:46 2017 +0800

    ipv6: set rt6i_protocol properly in the route when it is installed
    
    
    [ Upstream commit b91d532928dff2141ea9c107c3e73104d9843767 ]
    
    After commit c2ed1880fd61 ("net: ipv6: check route protocol when
    deleting routes"), ipv6 route checks rt protocol when trying to
    remove a rt entry.
    
    It introduced a side effect causing 'ip -6 route flush cache' not
    to work well. When flushing caches with iproute, all route caches
    get dumped from kernel then removed one by one by sending DELROUTE
    requests to kernel for each cache.
    
    The thing is iproute sends the request with the cache whose proto
    is set with RTPROT_REDIRECT by rt6_fill_node() when kernel dumps
    it. But in kernel the rt_cache protocol is still 0, which causes
    the cache not to be matched and removed.
    
    So the real reason is rt6i_protocol in the route is not set when
    it is allocated. As David Ahern's suggestion, this patch is to
    set rt6i_protocol properly in the route when it is installed and
    remove the codes setting rtm_protocol according to rt6i_flags in
    rt6_fill_node.
    
    This is also an improvement to keep rt6i_protocol consistent with
    rtm_protocol.
    
    Fixes: c2ed1880fd61 ("net: ipv6: check route protocol when deleting routes")
    Reported-by: Jianlin Shi <jishi@redhat.com>
    Suggested-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/net/ipv6/route.c b/net/ipv6/route.c
index bc49f9a82994..aeb7097acc0a 100644
--- a/net/ipv6/route.c
+++ b/net/ipv6/route.c
@@ -2366,6 +2366,7 @@ static void rt6_do_redirect(struct dst_entry *dst, struct sock *sk, struct sk_bu
 	if (on_link)
 		nrt->rt6i_flags &= ~RTF_GATEWAY;
 
+	nrt->rt6i_protocol = RTPROT_REDIRECT;
 	nrt->rt6i_gateway = *(struct in6_addr *)neigh->primary_key;
 
 	if (ip6_ins_rt(nrt))
@@ -2470,6 +2471,7 @@ static struct rt6_info *rt6_add_route_info(struct net *net,
 		.fc_dst_len	= prefixlen,
 		.fc_flags	= RTF_GATEWAY | RTF_ADDRCONF | RTF_ROUTEINFO |
 				  RTF_UP | RTF_PREF(pref),
+		.fc_protocol = RTPROT_RA,
 		.fc_nlinfo.portid = 0,
 		.fc_nlinfo.nlh = NULL,
 		.fc_nlinfo.nl_net = net,
@@ -2522,6 +2524,7 @@ struct rt6_info *rt6_add_dflt_router(const struct in6_addr *gwaddr,
 		.fc_ifindex	= dev->ifindex,
 		.fc_flags	= RTF_GATEWAY | RTF_ADDRCONF | RTF_DEFAULT |
 				  RTF_UP | RTF_EXPIRES | RTF_PREF(pref),
+		.fc_protocol = RTPROT_RA,
 		.fc_nlinfo.portid = 0,
 		.fc_nlinfo.nlh = NULL,
 		.fc_nlinfo.nl_net = dev_net(dev),
@@ -3434,14 +3437,6 @@ static int rt6_fill_node(struct net *net,
 	rtm->rtm_flags = 0;
 	rtm->rtm_scope = RT_SCOPE_UNIVERSE;
 	rtm->rtm_protocol = rt->rt6i_protocol;
-	if (rt->rt6i_flags & RTF_DYNAMIC)
-		rtm->rtm_protocol = RTPROT_REDIRECT;
-	else if (rt->rt6i_flags & RTF_ADDRCONF) {
-		if (rt->rt6i_flags & (RTF_DEFAULT | RTF_ROUTEINFO))
-			rtm->rtm_protocol = RTPROT_RA;
-		else
-			rtm->rtm_protocol = RTPROT_KERNEL;
-	}
 
 	if (rt->rt6i_flags & RTF_CACHE)
 		rtm->rtm_flags |= RTM_F_CLONED;
diff -uN a/1.txt b/1.txt
--- a/dummy/rpi_1004_f725c58799604308406e169b98e9e3955a97efae.txt	1970-01-01 00:00:00.000000000 +0000
+++ b/dummy/rpi_1004_f725c58799604308406e169b98e9e3955a97efae.txt	2013-12-23 04:07:40.000000000 +0000
@@ -0,0 +1 @@
+dummy file to ensure patch has content.
