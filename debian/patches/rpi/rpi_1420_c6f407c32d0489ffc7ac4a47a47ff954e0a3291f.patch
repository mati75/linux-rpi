commit c6f407c32d0489ffc7ac4a47a47ff954e0a3291f
Author: Dave Stevenson <dave.stevenson@raspberrypi.org>
Date:   Mon Sep 24 17:33:37 2018 +0100

    staging: mmal-vchiq: Make a mmal_buf struct for passing parameters
    
    The callback from vchi_mmal to the client was growing lots of extra
    parameters. Consolidate them into a single struct instead of
    growing the list further.
    The struct is associated with the client buffer, therefore there
    are various changes to setup various containers for the struct,
    and pass the appropriate members.
    
    Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.org>

Index: linuxtest/drivers/staging/vc04_services/vchiq-mmal/mmal-common.h
===================================================================
--- linuxtest.orig/drivers/staging/vc04_services/vchiq-mmal/mmal-common.h
+++ linuxtest/drivers/staging/vc04_services/vchiq-mmal/mmal-common.h
@@ -50,6 +50,11 @@ struct mmal_buffer {
 	unsigned long buffer_size; /* size of allocated buffer */
 
 	struct mmal_msg_context *msg_context;
+
+	unsigned long length;
+	u32 mmal_flags;
+	s64 dts;
+	s64 pts;
 };
 
 /* */
Index: linuxtest/drivers/staging/vc04_services/vchiq-mmal/mmal-vchiq.c
===================================================================
--- linuxtest.orig/drivers/staging/vc04_services/vchiq-mmal/mmal-vchiq.c
+++ linuxtest/drivers/staging/vc04_services/vchiq-mmal/mmal-vchiq.c
@@ -258,17 +258,25 @@ static void buffer_work_cb(struct work_s
 {
 	struct mmal_msg_context *msg_context =
 		container_of(work, struct mmal_msg_context, u.bulk.work);
+	struct mmal_buffer *buffer = msg_context->u.bulk.buffer;
+
+	if (!buffer) {
+		pr_err("%s: ctx: %p, No mmal buffer to pass details\n",
+		       __func__, msg_context);
+		return;
+	}
+
+	buffer->length = msg_context->u.bulk.buffer_used;
+	buffer->mmal_flags = msg_context->u.bulk.mmal_flags;
+	buffer->dts = msg_context->u.bulk.dts;
+	buffer->pts = msg_context->u.bulk.pts;
 
 	atomic_dec(&msg_context->u.bulk.port->buffers_with_vpu);
 
 	msg_context->u.bulk.port->buffer_cb(msg_context->u.bulk.instance,
 					    msg_context->u.bulk.port,
 					    msg_context->u.bulk.status,
-					    msg_context->u.bulk.buffer,
-					    msg_context->u.bulk.buffer_used,
-					    msg_context->u.bulk.mmal_flags,
-					    msg_context->u.bulk.dts,
-					    msg_context->u.bulk.pts);
+					    msg_context->u.bulk.buffer);
 }
 
 /* workqueue scheduled callback to handle receiving buffers
@@ -1326,11 +1334,14 @@ static int port_disable(struct vchiq_mma
 			mmalbuf = list_entry(buf_head, struct mmal_buffer,
 					     list);
 			list_del(buf_head);
-			if (port->buffer_cb)
+			if (port->buffer_cb) {
+				mmalbuf->length = 0;
+				mmalbuf->mmal_flags = 0;
+				mmalbuf->dts = MMAL_TIME_UNKNOWN;
+				mmalbuf->pts = MMAL_TIME_UNKNOWN;
 				port->buffer_cb(instance,
-						port, 0, mmalbuf, 0, 0,
-						MMAL_TIME_UNKNOWN,
-						MMAL_TIME_UNKNOWN);
+						port, 0, mmalbuf);
+			}
 		}
 
 		spin_unlock_irqrestore(&port->slock, flags);
Index: linuxtest/dummy/rpi_1420_c6f407c32d0489ffc7ac4a47a47ff954e0a3291f.txt
===================================================================
--- /dev/null
+++ linuxtest/dummy/rpi_1420_c6f407c32d0489ffc7ac4a47a47ff954e0a3291f.txt
@@ -0,0 +1 @@
+dummy file to ensure patch has content.
