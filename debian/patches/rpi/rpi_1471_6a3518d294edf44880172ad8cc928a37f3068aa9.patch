commit 6a3518d294edf44880172ad8cc928a37f3068aa9
Author: Shu Wang <shuwang@redhat.com>
Date:   Fri Sep 8 18:48:33 2017 +0800

    cifs: release auth_key.response for reconnect.
    
    commit f5c4ba816315d3b813af16f5571f86c8d4e897bd upstream.
    
    There is a race that cause cifs reconnect in cifs_mount,
    - cifs_mount
      - cifs_get_tcp_session
        - [ start thread cifs_demultiplex_thread
          - cifs_read_from_socket: -ECONNABORTED
            - DELAY_WORK smb2_reconnect_server ]
      - cifs_setup_session
      - [ smb2_reconnect_server ]
    
    auth_key.response was allocated in cifs_setup_session, and
    will release when the session destoried. So when session re-
    connect, auth_key.response should be check and released.
    
    Tested with my system:
    CIFS VFS: Free previous auth_key.response = ffff8800320bbf80
    
    A simple auth_key.response allocation call trace:
    - cifs_setup_session
    - SMB2_sess_setup
    - SMB2_sess_auth_rawntlmssp_authenticate
    - build_ntlmssp_auth_blob
    - setup_ntlmv2_rsp
    
    Signed-off-by: Shu Wang <shuwang@redhat.com>
    Signed-off-by: Steve French <smfrench@gmail.com>
    Reviewed-by: Ronnie Sahlberg <lsahlber@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/cifs/connect.c b/fs/cifs/connect.c
index 1a545695f547..f6712b6128d8 100644
--- a/fs/cifs/connect.c
+++ b/fs/cifs/connect.c
@@ -4071,6 +4071,14 @@ cifs_setup_session(const unsigned int xid, struct cifs_ses *ses,
 	cifs_dbg(FYI, "Security Mode: 0x%x Capabilities: 0x%x TimeAdjust: %d\n",
 		 server->sec_mode, server->capabilities, server->timeAdj);
 
+	if (ses->auth_key.response) {
+		cifs_dbg(VFS, "Free previous auth_key.response = %p\n",
+			 ses->auth_key.response);
+		kfree(ses->auth_key.response);
+		ses->auth_key.response = NULL;
+		ses->auth_key.len = 0;
+	}
+
 	if (server->ops->sess_setup)
 		rc = server->ops->sess_setup(xid, ses, nls_info);
 
