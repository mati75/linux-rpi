commit 49c473e1237efef30cb060f7ee63e242b0f5d62f
Author: Aneesh Kumar K.V <aneesh.kumar@linux.ibm.com>
Date:   Wed Jan 23 11:51:38 2019 +0530

    powerpc/radix: Fix kernel crash with mremap()
    
    commit 579b9239c1f38665b21e8d0e6ee83ecc96dbd6bb upstream.
    
    With support for split pmd lock, we use pmd page pmd_huge_pte pointer
    to store the deposited page table. In those config when we move page
    tables we need to make sure we move the deposited page table to the
    correct pmd page. Otherwise this can result in crash when we withdraw
    of deposited page table because we can find the pmd_huge_pte NULL.
    
    eg:
    
      __split_huge_pmd+0x1070/0x1940
      __split_huge_pmd+0xe34/0x1940 (unreliable)
      vma_adjust_trans_huge+0x110/0x1c0
      __vma_adjust+0x2b4/0x9b0
      __split_vma+0x1b8/0x280
      __do_munmap+0x13c/0x550
      sys_mremap+0x220/0x7e0
      system_call+0x5c/0x70
    
    Fixes: 675d995297d4 ("powerpc/book3s64: Enable split pmd ptlock.")
    Cc: stable@vger.kernel.org # v4.18+
    Signed-off-by: Aneesh Kumar K.V <aneesh.kumar@linux.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/powerpc/include/asm/book3s/64/pgtable.h b/arch/powerpc/include/asm/book3s/64/pgtable.h
index 2a2486526d1f..855dbae6d351 100644
--- a/arch/powerpc/include/asm/book3s/64/pgtable.h
+++ b/arch/powerpc/include/asm/book3s/64/pgtable.h
@@ -1234,21 +1234,13 @@ extern pmd_t pmdp_invalidate(struct vm_area_struct *vma, unsigned long address,
 
 #define pmd_move_must_withdraw pmd_move_must_withdraw
 struct spinlock;
-static inline int pmd_move_must_withdraw(struct spinlock *new_pmd_ptl,
-					 struct spinlock *old_pmd_ptl,
-					 struct vm_area_struct *vma)
-{
-	if (radix_enabled())
-		return false;
-	/*
-	 * Archs like ppc64 use pgtable to store per pmd
-	 * specific information. So when we switch the pmd,
-	 * we should also withdraw and deposit the pgtable
-	 */
-	return true;
-}
-
-
+extern int pmd_move_must_withdraw(struct spinlock *new_pmd_ptl,
+				  struct spinlock *old_pmd_ptl,
+				  struct vm_area_struct *vma);
+/*
+ * Hash translation mode use the deposited table to store hash pte
+ * slot information.
+ */
 #define arch_needs_pgtable_deposit arch_needs_pgtable_deposit
 static inline bool arch_needs_pgtable_deposit(void)
 {
diff --git a/arch/powerpc/mm/pgtable-book3s64.c b/arch/powerpc/mm/pgtable-book3s64.c
index 01d7c0f7c4f0..297db665d953 100644
--- a/arch/powerpc/mm/pgtable-book3s64.c
+++ b/arch/powerpc/mm/pgtable-book3s64.c
@@ -477,3 +477,25 @@ void arch_report_meminfo(struct seq_file *m)
 		   atomic_long_read(&direct_pages_count[MMU_PAGE_1G]) << 20);
 }
 #endif /* CONFIG_PROC_FS */
+
+/*
+ * For hash translation mode, we use the deposited table to store hash slot
+ * information and they are stored at PTRS_PER_PMD offset from related pmd
+ * location. Hence a pmd move requires deposit and withdraw.
+ *
+ * For radix translation with split pmd ptl, we store the deposited table in the
+ * pmd page. Hence if we have different pmd page we need to withdraw during pmd
+ * move.
+ *
+ * With hash we use deposited table always irrespective of anon or not.
+ * With radix we use deposited table only for anonymous mapping.
+ */
+int pmd_move_must_withdraw(struct spinlock *new_pmd_ptl,
+			   struct spinlock *old_pmd_ptl,
+			   struct vm_area_struct *vma)
+{
+	if (radix_enabled())
+		return (new_pmd_ptl != old_pmd_ptl) && vma_is_anonymous(vma);
+
+	return true;
+}
diff -uN a/1.txt b/1.txt
--- a/dummy/rpi_1335_49c473e1237efef30cb060f7ee63e242b0f5d62f.txt	1970-01-01 00:00:00.000000000 +0000
+++ b/dummy/rpi_1335_49c473e1237efef30cb060f7ee63e242b0f5d62f.txt	2013-12-23 04:07:40.000000000 +0000
@@ -0,0 +1 @@
+dummy file to ensure patch has content.
