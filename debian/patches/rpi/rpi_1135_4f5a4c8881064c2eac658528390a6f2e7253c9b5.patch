commit 4f5a4c8881064c2eac658528390a6f2e7253c9b5
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Wed Mar 6 15:41:57 2019 +0100

    gfs2: Fix missed wakeups in find_insert_glock
    
    commit 605b0487f0bc1ae9963bf52ece0f5c8055186f81 upstream.
    
    Mark Syms has reported seeing tasks that are stuck waiting in
    find_insert_glock.  It turns out that struct lm_lockname contains four padding
    bytes on 64-bit architectures that function glock_waitqueue doesn't skip when
    hashing the glock name.  As a result, we can end up waking up the wrong
    waitqueue, and the waiting tasks may be stuck forever.
    
    Fix that by using ht_parms.key_len instead of sizeof(struct lm_lockname) for
    the key length.
    
    Reported-by: Mark Syms <mark.syms@citrix.com>
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/gfs2/glock.c b/fs/gfs2/glock.c
index 4614ee25f621..9d566e62684c 100644
--- a/fs/gfs2/glock.c
+++ b/fs/gfs2/glock.c
@@ -107,7 +107,7 @@ static int glock_wake_function(wait_queue_entry_t *wait, unsigned int mode,
 
 static wait_queue_head_t *glock_waitqueue(struct lm_lockname *name)
 {
-	u32 hash = jhash2((u32 *)name, sizeof(*name) / 4, 0);
+	u32 hash = jhash2((u32 *)name, ht_parms.key_len / 4, 0);
 
 	return glock_wait_table + hash_32(hash, GLOCK_WAIT_TABLE_BITS);
 }
diff -uN a/1.txt b/1.txt
--- a/dummy/rpi_1135_4f5a4c8881064c2eac658528390a6f2e7253c9b5.txt	1970-01-01 00:00:00.000000000 +0000
+++ b/dummy/rpi_1135_4f5a4c8881064c2eac658528390a6f2e7253c9b5.txt	2013-12-23 04:07:40.000000000 +0000
@@ -0,0 +1 @@
+dummy file to ensure patch has content.
