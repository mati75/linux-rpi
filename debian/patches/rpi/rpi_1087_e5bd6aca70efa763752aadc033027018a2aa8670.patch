commit e5bd6aca70efa763752aadc033027018a2aa8670
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Tue Aug 21 11:53:03 2018 +0200

    spi: Fix double IDR allocation with DT aliases
    
    commit 04b2d03a75652bda989de1595048f0501dc0c0a0 upstream.
    
    If the SPI bus number is provided by a DT alias, idr_alloc() is called
    twice, leading to:
    
        WARNING: CPU: 1 PID: 1 at drivers/spi/spi.c:2179 spi_register_controller+0x11c/0x5d8
        couldn't get idr
    
    Fix this by moving the handling of fixed SPI bus numbers up, before the
    DT handling code fills in ctlr->bus_num.
    
    Fixes: 1a4327fbf4554d5b ("spi: fix IDR collision on systems with both fixed and dynamic SPI bus numbers")
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Tested-by: Fabio Estevam <fabio.estevam@nxp.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Cc: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
    Cc: Kirill Kapranov <kirill.kapranov@compulab.co.il>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index a00d006d4c3a..9da0bc5a036c 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -2143,8 +2143,17 @@ int spi_register_controller(struct spi_controller *ctlr)
 	 */
 	if (ctlr->num_chipselect == 0)
 		return -EINVAL;
-	/* allocate dynamic bus number using Linux idr */
-	if ((ctlr->bus_num < 0) && ctlr->dev.of_node) {
+	if (ctlr->bus_num >= 0) {
+		/* devices with a fixed bus num must check-in with the num */
+		mutex_lock(&board_lock);
+		id = idr_alloc(&spi_master_idr, ctlr, ctlr->bus_num,
+			ctlr->bus_num + 1, GFP_KERNEL);
+		mutex_unlock(&board_lock);
+		if (WARN(id < 0, "couldn't get idr"))
+			return id == -ENOSPC ? -EBUSY : id;
+		ctlr->bus_num = id;
+	} else if (ctlr->dev.of_node) {
+		/* allocate dynamic bus number using Linux idr */
 		id = of_alias_get_id(ctlr->dev.of_node, "spi");
 		if (id >= 0) {
 			ctlr->bus_num = id;
@@ -2170,15 +2179,6 @@ int spi_register_controller(struct spi_controller *ctlr)
 		if (WARN(id < 0, "couldn't get idr"))
 			return id;
 		ctlr->bus_num = id;
-	} else {
-		/* devices with a fixed bus num must check-in with the num */
-		mutex_lock(&board_lock);
-		id = idr_alloc(&spi_master_idr, ctlr, ctlr->bus_num,
-			ctlr->bus_num + 1, GFP_KERNEL);
-		mutex_unlock(&board_lock);
-		if (WARN(id < 0, "couldn't get idr"))
-			return id == -ENOSPC ? -EBUSY : id;
-		ctlr->bus_num = id;
 	}
 	INIT_LIST_HEAD(&ctlr->queue);
 	spin_lock_init(&ctlr->queue_lock);
diff -uN a/1.txt b/1.txt
--- a/dummy/rpi_1087_e5bd6aca70efa763752aadc033027018a2aa8670.txt	1970-01-01 00:00:00.000000000 +0000
+++ b/dummy/rpi_1087_e5bd6aca70efa763752aadc033027018a2aa8670.txt	2013-12-23 04:07:40.000000000 +0000
@@ -0,0 +1 @@
+dummy file to ensure patch has content.
