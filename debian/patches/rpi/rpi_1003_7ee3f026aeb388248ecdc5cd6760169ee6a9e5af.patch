commit 7ee3f026aeb388248ecdc5cd6760169ee6a9e5af
Author: Heiko Carstens <heiko.carstens@de.ibm.com>
Date:   Mon Sep 11 11:24:22 2017 +0200

    s390/guarded storage: fix possible memory corruption
    
    commit fa1edf3f63c05ca8eacafcd7048ed91e5360f1a8 upstream.
    
    For PREEMPT enabled kernels the guarded storage (GS) code contains a
    possible use-after-free bug. If a task that makes use of GS exits, it
    will execute do_exit() while still enabled for preemption.
    
    That function will call exit_thread_runtime_instr() via exit_thread().
    If exit_thread_gs() gets preempted after the GS control block of the
    task has been freed but before the pointer to it is set to NULL, then
    save_gs_cb(), called from switch_to(), will write to already freed
    memory.
    
    Avoid this and simply disable preemption while freeing the control
    block and setting the pointer to NULL.
    
    Fixes: 916cda1aa1b4 ("s390: add a system call for guarded storage")
    Reviewed-by: Christian Borntraeger <borntraeger@de.ibm.com>
    Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/s390/kernel/guarded_storage.c b/arch/s390/kernel/guarded_storage.c
index bff39b66c9ff..9ee794e14f33 100644
--- a/arch/s390/kernel/guarded_storage.c
+++ b/arch/s390/kernel/guarded_storage.c
@@ -14,9 +14,11 @@
 
 void exit_thread_gs(void)
 {
+	preempt_disable();
 	kfree(current->thread.gs_cb);
 	kfree(current->thread.gs_bc_cb);
 	current->thread.gs_cb = current->thread.gs_bc_cb = NULL;
+	preempt_enable();
 }
 
 static int gs_enable(void)
diff -uN a/1.txt b/1.txt
--- a/dummy/rpi_1003_7ee3f026aeb388248ecdc5cd6760169ee6a9e5af.txt	1970-01-01 00:00:00.000000000 +0000
+++ b/dummy/rpi_1003_7ee3f026aeb388248ecdc5cd6760169ee6a9e5af.txt	2013-12-23 04:07:40.000000000 +0000
@@ -0,0 +1 @@
+dummy file to ensure patch has content.
