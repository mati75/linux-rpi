commit 04393d25720708f809dd877a69391c715a45d4f7
Author: Lyude Paul <lyude@redhat.com>
Date:   Thu Aug 9 18:22:06 2018 -0400

    drm/nouveau: Reset MST branching unit before enabling
    
    commit fa3cdf8d0b092c4561f9f017dfac409eb7644737 upstream.
    
    When probing a new MST device, it's not safe to make any assumptions
    about it's current state. While most well mannered MST hubs will just
    disable the branching unit on hotplug disconnects, this isn't enough to
    save us from various other scenarios that might have resulted in
    something writing to the MST branching unit before we got control of it.
    This could happen if a previous probe we tried failed, if we're booting
    in kexec context and the hub is still in the state the last kernel put
    it in, etc.
    
    Luckily; there is no reason we can't just reset the branching unit
    every time we enable a new topology. So, fix this by resetting it on
    enabling new topologies to ensure that we always start off with a clean,
    unmodified topology state on MST sinks.
    
    This fixes occasional hard-lockups on my P50's laptop dock (e.g. AUX
    times out all DPCD trasactions) observed after multiple docks, undocks,
    and module reloads.
    
    Signed-off-by: Lyude Paul <lyude@redhat.com>
    Cc: stable@vger.kernel.org
    Cc: Karol Herbst <karolherbst@gmail.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/gpu/drm/nouveau/dispnv50/disp.c b/drivers/gpu/drm/nouveau/dispnv50/disp.c
index 9bae4db84cfb..c65eae6f03b9 100644
--- a/drivers/gpu/drm/nouveau/dispnv50/disp.c
+++ b/drivers/gpu/drm/nouveau/dispnv50/disp.c
@@ -1098,17 +1098,21 @@ nv50_mstm_enable(struct nv50_mstm *mstm, u8 dpcd, int state)
 	int ret;
 
 	if (dpcd >= 0x12) {
-		ret = drm_dp_dpcd_readb(mstm->mgr.aux, DP_MSTM_CTRL, &dpcd);
+		/* Even if we're enabling MST, start with disabling the
+		 * branching unit to clear any sink-side MST topology state
+		 * that wasn't set by us
+		 */
+		ret = drm_dp_dpcd_writeb(mstm->mgr.aux, DP_MSTM_CTRL, 0);
 		if (ret < 0)
 			return ret;
 
-		dpcd &= ~DP_MST_EN;
-		if (state)
-			dpcd |= DP_MST_EN;
-
-		ret = drm_dp_dpcd_writeb(mstm->mgr.aux, DP_MSTM_CTRL, dpcd);
-		if (ret < 0)
-			return ret;
+		if (state) {
+			/* Now, start initializing */
+			ret = drm_dp_dpcd_writeb(mstm->mgr.aux, DP_MSTM_CTRL,
+						 DP_MST_EN);
+			if (ret < 0)
+				return ret;
+		}
 	}
 
 	return nvif_mthd(disp, 0, &args, sizeof(args));
diff -uN a/1.txt b/1.txt
--- a/dummy/rpi_1061_04393d25720708f809dd877a69391c715a45d4f7.txt	1970-01-01 00:00:00.000000000 +0000
+++ b/dummy/rpi_1061_04393d25720708f809dd877a69391c715a45d4f7.txt	2013-12-23 04:07:40.000000000 +0000
@@ -0,0 +1 @@
+dummy file to ensure patch has content.
