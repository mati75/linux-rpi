commit 095cfdf857a38972762d92379a848349fda00fe1
Author: Hongbo Yao <yaohongbo@huawei.com>
Date:   Mon Jan 7 10:22:07 2019 +0800

    nvme-pci: fix out of bounds access in nvme_cqe_pending
    
    [ Upstream commit dcca1662727220d18fa351097ddff33f95f516c5 ]
    
    There is an out of bounds array access in nvme_cqe_peding().
    
    When enable irq_thread for nvme interrupt, there is racing between the
    nvmeq->cq_head updating and reading.
    
    nvmeq->cq_head is updated in nvme_update_cq_head(), if nvmeq->cq_head
    equals nvmeq->q_depth and before its value set to zero, nvme_cqe_pending()
    uses its value as an array index, the index will be out of bounds.
    
    Signed-off-by: Hongbo Yao <yaohongbo@huawei.com>
    [hch: slight coding style update]
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

diff --git a/drivers/nvme/host/pci.c b/drivers/nvme/host/pci.c
index 40f76b4f08fc..f46313f441ec 100644
--- a/drivers/nvme/host/pci.c
+++ b/drivers/nvme/host/pci.c
@@ -908,9 +908,11 @@ static void nvme_complete_cqes(struct nvme_queue *nvmeq, u16 start, u16 end)
 
 static inline void nvme_update_cq_head(struct nvme_queue *nvmeq)
 {
-	if (++nvmeq->cq_head == nvmeq->q_depth) {
+	if (nvmeq->cq_head == nvmeq->q_depth - 1) {
 		nvmeq->cq_head = 0;
 		nvmeq->cq_phase = !nvmeq->cq_phase;
+	} else {
+		nvmeq->cq_head++;
 	}
 }
 
diff -uN a/1.txt b/1.txt
--- a/dummy/rpi_1389_095cfdf857a38972762d92379a848349fda00fe1.txt	1970-01-01 00:00:00.000000000 +0000
+++ b/dummy/rpi_1389_095cfdf857a38972762d92379a848349fda00fe1.txt	2013-12-23 04:07:40.000000000 +0000
@@ -0,0 +1 @@
+dummy file to ensure patch has content.
