commit 0f478f25d50cb6464678284a13f514fefc16e271
Author: Sasha Neftin <sasha.neftin@intel.com>
Date:   Sun Aug 6 16:49:18 2017 +0300

    e1000e: fix buffer overrun while the I219 is processing DMA transactions
    
    commit b10effb92e272051dd1ec0d7be56bf9ca85ab927 upstream.
    
    IntelÂ® 100/200 Series Chipset platforms reduced the round-trip
    latency for the LAN Controller DMA accesses, causing in some high
    performance cases a buffer overrun while the I219 LAN Connected
    Device is processing the DMA transactions. I219LM and I219V devices
    can fall into unrecovered Tx hang under very stressfully UDP traffic
    and multiple reconnection of Ethernet cable. This Tx hang of the LAN
    Controller is only recovered if the system is rebooted. Slightly slow
    down DMA access by reducing the number of outstanding requests.
    This workaround could have an impact on TCP traffic performance
    on the platform. Disabling TSO eliminates performance loss for TCP
    traffic without a noticeable impact on CPU performance.
    
    Please, refer to I218/I219 specification update:
    https://www.intel.com/content/www/us/en/embedded/products/networking/
    ethernet-connection-i218-family-documentation.html
    
    Signed-off-by: Sasha Neftin <sasha.neftin@intel.com>
    Reviewed-by: Dima Ruinskiy <dima.ruinskiy@intel.com>
    Reviewed-by: Raanan Avargil <raanan.avargil@intel.com>
    Tested-by: Aaron Brown <aaron.f.brown@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
    Signed-off-by: Amit Pundir <amit.pundir@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/net/ethernet/intel/e1000e/netdev.c b/drivers/net/ethernet/intel/e1000e/netdev.c
index 99e5ef561f06..c38b00c90f48 100644
--- a/drivers/net/ethernet/intel/e1000e/netdev.c
+++ b/drivers/net/ethernet/intel/e1000e/netdev.c
@@ -3021,8 +3021,8 @@ static void e1000_configure_tx(struct e1000_adapter *adapter)
 
 	hw->mac.ops.config_collision_dist(hw);
 
-	/* SPT and CNP Si errata workaround to avoid data corruption */
-	if (hw->mac.type >= e1000_pch_spt) {
+	/* SPT and KBL Si errata workaround to avoid data corruption */
+	if (hw->mac.type == e1000_pch_spt) {
 		u32 reg_val;
 
 		reg_val = er32(IOSFPC);
@@ -3030,7 +3030,9 @@ static void e1000_configure_tx(struct e1000_adapter *adapter)
 		ew32(IOSFPC, reg_val);
 
 		reg_val = er32(TARC(0));
-		reg_val |= E1000_TARC0_CB_MULTIQ_3_REQ;
+		/* SPT and KBL Si errata workaround to avoid Tx hang */
+		reg_val &= ~BIT(28);
+		reg_val |= BIT(29);
 		ew32(TARC(0), reg_val);
 	}
 }
diff -uN a/1.txt b/1.txt
--- a/dummy/rpi_1192_0f478f25d50cb6464678284a13f514fefc16e271.txt	1970-01-01 00:00:00.000000000 +0000
+++ b/dummy/rpi_1192_0f478f25d50cb6464678284a13f514fefc16e271.txt	2013-12-23 04:07:40.000000000 +0000
@@ -0,0 +1 @@
+dummy file to ensure patch has content.
