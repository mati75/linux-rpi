commit 7b95e7d9246e5510ab47b6fed43f545f20a2193c
Author: Avraham Stern <avraham.stern@intel.com>
Date:   Fri Aug 18 15:33:57 2017 +0300

    mac80211: flush hw_roc_start work before cancelling the ROC
    
    commit 6e46d8ce894374fc135c96a8d1057c6af1fef237 upstream.
    
    When HW ROC is supported it is possible that after the HW notified
    that the ROC has started, the ROC was cancelled and another ROC was
    added while the hw_roc_start worker is waiting on the mutex (since
    cancelling the ROC and adding another one also holds the same mutex).
    As a result, the hw_roc_start worker will continue to run after the
    new ROC is added but before it is actually started by the HW.
    This may result in notifying userspace that the ROC has started before
    it actually does, or in case of management tx ROC, in an attempt to
    tx while not on the right channel.
    
    In addition, when the driver will notify mac80211 that the second ROC
    has started, mac80211 will warn that this ROC has already been
    notified.
    
    Fix this by flushing the hw_roc_start work before cancelling an ROC.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Avraham Stern <avraham.stern@intel.com>
    Signed-off-by: Luca Coelho <luciano.coelho@intel.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/net/mac80211/offchannel.c b/net/mac80211/offchannel.c
index eede5c6db8d5..30bba53c2992 100644
--- a/net/mac80211/offchannel.c
+++ b/net/mac80211/offchannel.c
@@ -707,6 +707,8 @@ static int ieee80211_cancel_roc(struct ieee80211_local *local,
 	if (!cookie)
 		return -ENOENT;
 
+	flush_work(&local->hw_roc_start);
+
 	mutex_lock(&local->mtx);
 	list_for_each_entry_safe(roc, tmp, &local->roc_list, list) {
 		if (!mgmt_tx && roc->cookie != cookie)
