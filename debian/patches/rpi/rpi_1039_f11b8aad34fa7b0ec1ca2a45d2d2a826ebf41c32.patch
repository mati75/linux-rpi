commit f11b8aad34fa7b0ec1ca2a45d2d2a826ebf41c32
Author: Boris Brezillon <boris.brezillon@bootlin.com>
Date:   Mon Sep 17 16:31:30 2018 +0200

    mtd: devices: m25p80: Make sure the buffer passed in op is DMA-able
    
    commit 4a3e85f2674cbfb81052059107d0165269778e2f upstream.
    
    As documented in spi-mem.h, spi_mem_op->data.buf.{in,out} must be
    DMA-able, and commit 4120f8d158ef ("mtd: spi-nor: Use the spi_mem_xx()
    API") failed to follow this rule as buffers passed to
    ->{read,write}_reg() are usually placed on the stack.
    
    Fix that by allocating a scratch buffer and copying the data around.
    
    Fixes: 4120f8d158ef ("mtd: spi-nor: Use the spi_mem_xx() API")
    Reported-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>
    Tested-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Reviewed-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/mtd/devices/m25p80.c b/drivers/mtd/devices/m25p80.c
index e84563d2067f..3463cd94a7f6 100644
--- a/drivers/mtd/devices/m25p80.c
+++ b/drivers/mtd/devices/m25p80.c
@@ -41,13 +41,23 @@ static int m25p80_read_reg(struct spi_nor *nor, u8 code, u8 *val, int len)
 	struct spi_mem_op op = SPI_MEM_OP(SPI_MEM_OP_CMD(code, 1),
 					  SPI_MEM_OP_NO_ADDR,
 					  SPI_MEM_OP_NO_DUMMY,
-					  SPI_MEM_OP_DATA_IN(len, val, 1));
+					  SPI_MEM_OP_DATA_IN(len, NULL, 1));
+	void *scratchbuf;
 	int ret;
 
+	scratchbuf = kmalloc(len, GFP_KERNEL);
+	if (!scratchbuf)
+		return -ENOMEM;
+
+	op.data.buf.in = scratchbuf;
 	ret = spi_mem_exec_op(flash->spimem, &op);
 	if (ret < 0)
 		dev_err(&flash->spimem->spi->dev, "error %d reading %x\n", ret,
 			code);
+	else
+		memcpy(val, scratchbuf, len);
+
+	kfree(scratchbuf);
 
 	return ret;
 }
@@ -58,9 +68,19 @@ static int m25p80_write_reg(struct spi_nor *nor, u8 opcode, u8 *buf, int len)
 	struct spi_mem_op op = SPI_MEM_OP(SPI_MEM_OP_CMD(opcode, 1),
 					  SPI_MEM_OP_NO_ADDR,
 					  SPI_MEM_OP_NO_DUMMY,
-					  SPI_MEM_OP_DATA_OUT(len, buf, 1));
+					  SPI_MEM_OP_DATA_OUT(len, NULL, 1));
+	void *scratchbuf;
+	int ret;
 
-	return spi_mem_exec_op(flash->spimem, &op);
+	scratchbuf = kmemdup(buf, len, GFP_KERNEL);
+	if (!scratchbuf)
+		return -ENOMEM;
+
+	op.data.buf.out = scratchbuf;
+	ret = spi_mem_exec_op(flash->spimem, &op);
+	kfree(scratchbuf);
+
+	return ret;
 }
 
 static ssize_t m25p80_write(struct spi_nor *nor, loff_t to, size_t len,
diff -uN a/1.txt b/1.txt
--- a/dummy/rpi_1039_f11b8aad34fa7b0ec1ca2a45d2d2a826ebf41c32.txt	1970-01-01 00:00:00.000000000 +0000
+++ b/dummy/rpi_1039_f11b8aad34fa7b0ec1ca2a45d2d2a826ebf41c32.txt	2013-12-23 04:07:40.000000000 +0000
@@ -0,0 +1 @@
+dummy file to ensure patch has content.
