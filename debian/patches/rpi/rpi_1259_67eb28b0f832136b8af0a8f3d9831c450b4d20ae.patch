commit 67eb28b0f832136b8af0a8f3d9831c450b4d20ae
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Aug 8 01:07:05 2018 -0700

    bus: ti-sysc: Fix module register ioremap for larger offsets
    
    [ Upstream commit 0ef8e3bb974af56346b34393e643d491d9141c66 ]
    
    We can have the interconnect target module control registers pretty
    much anywhere within the module range. The current code attempts an
    incomplete optimization of the ioremap size but does it wrong and
    it only works for registers at the beginning of the module.
    
    Let's just use the largest control register to calculate the ioremap
    size. The ioremapped range is for most part cached anyways so there
    is no need for size optimization. Let's also update the comments
    accordingly.
    
    Fixes: 0eecc636e5a2 ("bus: ti-sysc: Add minimal TI sysc interconnect
    target driver")
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Sasha Levin <alexander.levin@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/bus/ti-sysc.c b/drivers/bus/ti-sysc.c
index 80d60f43db56..b31bf03ea497 100644
--- a/drivers/bus/ti-sysc.c
+++ b/drivers/bus/ti-sysc.c
@@ -490,32 +490,29 @@ static int sysc_check_registers(struct sysc *ddata)
 
 /**
  * syc_ioremap - ioremap register space for the interconnect target module
- * @ddata: deviec driver data
+ * @ddata: device driver data
  *
  * Note that the interconnect target module registers can be anywhere
- * within the first child device address space. For example, SGX has
- * them at offset 0x1fc00 in the 32MB module address space. We just
- * what we need around the interconnect target module registers.
+ * within the interconnect target module range. For example, SGX has
+ * them at offset 0x1fc00 in the 32MB module address space. And cpsw
+ * has them at offset 0x1200 in the CPSW_WR child. Usually the
+ * the interconnect target module registers are at the beginning of
+ * the module range though.
  */
 static int sysc_ioremap(struct sysc *ddata)
 {
-	u32 size = 0;
-
-	if (ddata->offsets[SYSC_SYSSTATUS] >= 0)
-		size = ddata->offsets[SYSC_SYSSTATUS];
-	else if (ddata->offsets[SYSC_SYSCONFIG] >= 0)
-		size = ddata->offsets[SYSC_SYSCONFIG];
-	else if (ddata->offsets[SYSC_REVISION] >= 0)
-		size = ddata->offsets[SYSC_REVISION];
-	else
-		return -EINVAL;
+	int size;
 
-	size &= 0xfff00;
-	size += SZ_256;
+	size = max3(ddata->offsets[SYSC_REVISION],
+		    ddata->offsets[SYSC_SYSCONFIG],
+		    ddata->offsets[SYSC_SYSSTATUS]);
+
+	if (size < 0 || (size + sizeof(u32)) > ddata->module_size)
+		return -EINVAL;
 
 	ddata->module_va = devm_ioremap(ddata->dev,
 					ddata->module_pa,
-					size);
+					size + sizeof(u32));
 	if (!ddata->module_va)
 		return -EIO;
 
diff -uN a/1.txt b/1.txt
--- a/dummy/rpi_1259_67eb28b0f832136b8af0a8f3d9831c450b4d20ae.txt	1970-01-01 00:00:00.000000000 +0000
+++ b/dummy/rpi_1259_67eb28b0f832136b8af0a8f3d9831c450b4d20ae.txt	2013-12-23 04:07:40.000000000 +0000
@@ -0,0 +1 @@
+dummy file to ensure patch has content.
