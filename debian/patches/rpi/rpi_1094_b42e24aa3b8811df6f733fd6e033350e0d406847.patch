commit b42e24aa3b8811df6f733fd6e033350e0d406847
Author: Jan Kara <jack@suse.cz>
Date:   Thu Nov 8 14:01:16 2018 +0100

    loop: Get rid of 'nested' acquisition of loop_ctl_mutex
    
    commit c28445fa06a3a54e06938559b9514c5a7f01c90f upstream.
    
    The nested acquisition of loop_ctl_mutex (->lo_ctl_mutex back then) has
    been introduced by commit f028f3b2f987e "loop: fix circular locking in
    loop_clr_fd()" to fix lockdep complains about bd_mutex being acquired
    after lo_ctl_mutex during partition rereading. Now that these are
    properly fixed, let's stop fooling lockdep.
    
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/block/loop.c b/drivers/block/loop.c
index a517247a32fa..ec083665f1fd 100644
--- a/drivers/block/loop.c
+++ b/drivers/block/loop.c
@@ -682,7 +682,7 @@ static int loop_change_fd(struct loop_device *lo, struct block_device *bdev,
 	int		error;
 	bool		partscan;
 
-	error = mutex_lock_killable_nested(&loop_ctl_mutex, 1);
+	error = mutex_lock_killable(&loop_ctl_mutex);
 	if (error)
 		return error;
 	error = -ENXIO;
@@ -920,7 +920,7 @@ static int loop_set_fd(struct loop_device *lo, fmode_t mode,
 	if (!file)
 		goto out;
 
-	error = mutex_lock_killable_nested(&loop_ctl_mutex, 1);
+	error = mutex_lock_killable(&loop_ctl_mutex);
 	if (error)
 		goto out_putf;
 
@@ -1136,7 +1136,7 @@ static int loop_clr_fd(struct loop_device *lo)
 {
 	int err;
 
-	err = mutex_lock_killable_nested(&loop_ctl_mutex, 1);
+	err = mutex_lock_killable(&loop_ctl_mutex);
 	if (err)
 		return err;
 	if (lo->lo_state != Lo_bound) {
@@ -1173,7 +1173,7 @@ loop_set_status(struct loop_device *lo, const struct loop_info64 *info)
 	struct block_device *bdev;
 	bool partscan = false;
 
-	err = mutex_lock_killable_nested(&loop_ctl_mutex, 1);
+	err = mutex_lock_killable(&loop_ctl_mutex);
 	if (err)
 		return err;
 	if (lo->lo_encrypt_key_size &&
@@ -1278,7 +1278,7 @@ loop_get_status(struct loop_device *lo, struct loop_info64 *info)
 	struct kstat stat;
 	int ret;
 
-	ret = mutex_lock_killable_nested(&loop_ctl_mutex, 1);
+	ret = mutex_lock_killable(&loop_ctl_mutex);
 	if (ret)
 		return ret;
 	if (lo->lo_state != Lo_bound) {
@@ -1467,7 +1467,7 @@ static int lo_simple_ioctl(struct loop_device *lo, unsigned int cmd,
 {
 	int err;
 
-	err = mutex_lock_killable_nested(&loop_ctl_mutex, 1);
+	err = mutex_lock_killable(&loop_ctl_mutex);
 	if (err)
 		return err;
 	switch (cmd) {
diff -uN a/1.txt b/1.txt
--- a/dummy/rpi_1094_b42e24aa3b8811df6f733fd6e033350e0d406847.txt	1970-01-01 00:00:00.000000000 +0000
+++ b/dummy/rpi_1094_b42e24aa3b8811df6f733fd6e033350e0d406847.txt	2013-12-23 04:07:40.000000000 +0000
@@ -0,0 +1 @@
+dummy file to ensure patch has content.
