--- linux/drivers/staging/vc04_services/bcm2835-camera/bcm2835-camera.c	2019-03-18 09:58:07.003505941 +0100
+++ linux-5.0.y/drivers/staging/vc04_services/bcm2835-camera/bcm2835-camera.c	2019-03-20 18:17:15.210284161 +0100
@@ -4,11 +4,10 @@
  *
  * Copyright Â© 2013 Raspberry Pi (Trading) Ltd.
  *
- * Authors: Vincent Sanders @ Collabora
- *          Dave Stevenson @ Broadcom
- *		(now dave.stevenson@raspberrypi.org)
- *          Simon Mellor @ Broadcom
- *          Luke Diamand @ Broadcom
+ * Authors: Vincent Sanders <vincent.sanders@collabora.co.uk>
+ *          Dave Stevenson <dsteve@broadcom.com>
+ *          Simon Mellor <simellor@broadcom.com>
+ *          Luke Diamand <luked@broadcom.com>
  */
 
 #include <linux/errno.h>
@@ -72,12 +71,6 @@
 	tpf_max     = {.numerator = 1,	        .denominator = FPS_MIN},
 	tpf_default = {.numerator = 1000,	.denominator = 30000};
 
-/* Container for MMAL and VB2 buffers*/
-struct vb2_mmal_buffer {
-	struct vb2_v4l2_buffer	vb;
-	struct mmal_buffer	mmal;
-};
-
 /* video formats */
 static struct mmal_fmt formats[] = {
 	{
@@ -86,7 +79,7 @@
 		.flags = 0,
 		.mmal = MMAL_ENCODING_I420,
 		.depth = 12,
-		.mmal_component = COMP_CAMERA,
+		.mmal_component = MMAL_COMPONENT_CAMERA,
 		.ybbp = 1,
 		.remove_padding = 1,
 	}, {
@@ -95,7 +88,7 @@
 		.flags = 0,
 		.mmal = MMAL_ENCODING_YUYV,
 		.depth = 16,
-		.mmal_component = COMP_CAMERA,
+		.mmal_component = MMAL_COMPONENT_CAMERA,
 		.ybbp = 2,
 		.remove_padding = 0,
 	}, {
@@ -104,7 +97,7 @@
 		.flags = 0,
 		.mmal = MMAL_ENCODING_RGB24,
 		.depth = 24,
-		.mmal_component = COMP_CAMERA,
+		.mmal_component = MMAL_COMPONENT_CAMERA,
 		.ybbp = 3,
 		.remove_padding = 0,
 	}, {
@@ -113,7 +106,7 @@
 		.flags = V4L2_FMT_FLAG_COMPRESSED,
 		.mmal = MMAL_ENCODING_JPEG,
 		.depth = 8,
-		.mmal_component = COMP_IMAGE_ENCODE,
+		.mmal_component = MMAL_COMPONENT_IMAGE_ENCODE,
 		.ybbp = 0,
 		.remove_padding = 0,
 	}, {
@@ -122,7 +115,7 @@
 		.flags = V4L2_FMT_FLAG_COMPRESSED,
 		.mmal = MMAL_ENCODING_H264,
 		.depth = 8,
-		.mmal_component = COMP_VIDEO_ENCODE,
+		.mmal_component = MMAL_COMPONENT_VIDEO_ENCODE,
 		.ybbp = 0,
 		.remove_padding = 0,
 	}, {
@@ -131,7 +124,7 @@
 		.flags = V4L2_FMT_FLAG_COMPRESSED,
 		.mmal = MMAL_ENCODING_MJPEG,
 		.depth = 8,
-		.mmal_component = COMP_VIDEO_ENCODE,
+		.mmal_component = MMAL_COMPONENT_VIDEO_ENCODE,
 		.ybbp = 0,
 		.remove_padding = 0,
 	}, {
@@ -140,7 +133,7 @@
 		.flags = 0,
 		.mmal = MMAL_ENCODING_YVYU,
 		.depth = 16,
-		.mmal_component = COMP_CAMERA,
+		.mmal_component = MMAL_COMPONENT_CAMERA,
 		.ybbp = 2,
 		.remove_padding = 0,
 	}, {
@@ -149,7 +142,7 @@
 		.flags = 0,
 		.mmal = MMAL_ENCODING_VYUY,
 		.depth = 16,
-		.mmal_component = COMP_CAMERA,
+		.mmal_component = MMAL_COMPONENT_CAMERA,
 		.ybbp = 2,
 		.remove_padding = 0,
 	}, {
@@ -158,7 +151,7 @@
 		.flags = 0,
 		.mmal = MMAL_ENCODING_UYVY,
 		.depth = 16,
-		.mmal_component = COMP_CAMERA,
+		.mmal_component = MMAL_COMPONENT_CAMERA,
 		.ybbp = 2,
 		.remove_padding = 0,
 	}, {
@@ -167,7 +160,7 @@
 		.flags = 0,
 		.mmal = MMAL_ENCODING_NV12,
 		.depth = 12,
-		.mmal_component = COMP_CAMERA,
+		.mmal_component = MMAL_COMPONENT_CAMERA,
 		.ybbp = 1,
 		.remove_padding = 1,
 	}, {
@@ -176,7 +169,7 @@
 		.flags = 0,
 		.mmal = MMAL_ENCODING_BGR24,
 		.depth = 24,
-		.mmal_component = COMP_CAMERA,
+		.mmal_component = MMAL_COMPONENT_CAMERA,
 		.ybbp = 3,
 		.remove_padding = 0,
 	}, {
@@ -185,7 +178,7 @@
 		.flags = 0,
 		.mmal = MMAL_ENCODING_YV12,
 		.depth = 12,
-		.mmal_component = COMP_CAMERA,
+		.mmal_component = MMAL_COMPONENT_CAMERA,
 		.ybbp = 1,
 		.remove_padding = 1,
 	}, {
@@ -194,7 +187,7 @@
 		.flags = 0,
 		.mmal = MMAL_ENCODING_NV21,
 		.depth = 12,
-		.mmal_component = COMP_CAMERA,
+		.mmal_component = MMAL_COMPONENT_CAMERA,
 		.ybbp = 1,
 		.remove_padding = 1,
 	}, {
@@ -203,7 +196,7 @@
 		.flags = 0,
 		.mmal = MMAL_ENCODING_BGRA,
 		.depth = 32,
-		.mmal_component = COMP_CAMERA,
+		.mmal_component = MMAL_COMPONENT_CAMERA,
 		.ybbp = 4,
 		.remove_padding = 0,
 	},
@@ -242,22 +235,6 @@
 		return -EINVAL;
 	}
 
-	/* Handle CREATE_BUFS situation - *nplanes != 0 */
-	if (*nplanes) {
-		if (*nplanes != 1 ||
-		    sizes[0] < dev->capture.port->current_buffer.size) {
-			v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,
-				 "%s: dev:%p Invalid buffer request from CREATE_BUFS, size %u < %u, nplanes %u != 1\n",
-				 __func__, dev, sizes[0],
-				 dev->capture.port->current_buffer.size,
-				 *nplanes);
-			return -EINVAL;
-		} else {
-			return 0;
-		}
-	}
-
-	/* Handle REQBUFS situation */
 	size = dev->capture.port->current_buffer.size;
 	if (size == 0) {
 		v4l2_err(&dev->v4l2_dev,
@@ -289,15 +266,14 @@
 {
 	struct bm2835_mmal_dev *dev = vb2_get_drv_priv(vb->vb2_queue);
 	struct vb2_v4l2_buffer *vb2 = to_vb2_v4l2_buffer(vb);
-	struct vb2_mmal_buffer *buf =
-				container_of(vb2, struct vb2_mmal_buffer, vb);
+	struct mmal_buffer *buf = container_of(vb2, struct mmal_buffer, vb);
 
 	v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev, "%s: dev:%p, vb %p\n",
 		 __func__, dev, vb);
-	buf->mmal.buffer = vb2_plane_vaddr(&buf->vb.vb2_buf, 0);
-	buf->mmal.buffer_size = vb2_plane_size(&buf->vb.vb2_buf, 0);
+	buf->buffer = vb2_plane_vaddr(&buf->vb.vb2_buf, 0);
+	buf->buffer_size = vb2_plane_size(&buf->vb.vb2_buf, 0);
 
-	return mmal_vchi_buffer_init(dev->instance, &buf->mmal);
+	return mmal_vchi_buffer_init(dev->instance, buf);
 }
 
 static int buffer_prepare(struct vb2_buffer *vb)
@@ -326,34 +302,31 @@
 {
 	struct bm2835_mmal_dev *dev = vb2_get_drv_priv(vb->vb2_queue);
 	struct vb2_v4l2_buffer *vb2 = to_vb2_v4l2_buffer(vb);
-	struct vb2_mmal_buffer *buf =
-				container_of(vb2, struct vb2_mmal_buffer, vb);
+	struct mmal_buffer *buf = container_of(vb2, struct mmal_buffer, vb);
 
 	v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev, "%s: dev:%p, vb %p\n",
 		 __func__, dev, vb);
-
-	mmal_vchi_buffer_cleanup(&buf->mmal);
+	mmal_vchi_buffer_cleanup(buf);
 }
 
 static inline bool is_capturing(struct bm2835_mmal_dev *dev)
 {
 	return dev->capture.camera_port ==
-	    &dev->component[COMP_CAMERA]->output[CAM_PORT_CAPTURE];
+	    &dev->
+	    component[MMAL_COMPONENT_CAMERA]->output[MMAL_CAMERA_PORT_CAPTURE];
 }
 
 static void buffer_cb(struct vchiq_mmal_instance *instance,
 		      struct vchiq_mmal_port *port,
 		      int status,
-		      struct mmal_buffer *mmal_buf)
+		      struct mmal_buffer *buf,
+		      unsigned long length, u32 mmal_flags, s64 dts, s64 pts)
 {
 	struct bm2835_mmal_dev *dev = port->cb_ctx;
-	struct vb2_mmal_buffer *buf =
-			container_of(mmal_buf, struct vb2_mmal_buffer, mmal);
 
 	v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,
 		 "%s: status:%d, buf:%p, length:%lu, flags %u, pts %lld\n",
-		 __func__, status, buf, mmal_buf->length, mmal_buf->mmal_flags,
-		 mmal_buf->pts);
+		 __func__, status, buf, length, mmal_flags, pts);
 
 	if (status != 0) {
 		/* error in transfer */
@@ -362,17 +335,18 @@
 			vb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);
 		}
 		return;
-	}
-
-	if (mmal_buf->length == 0) {
+	} else if (length == 0) {
 		/* stream ended */
-		if (dev->capture.frame_count) {
-			/* empty buffer whilst capturing - expected to be an
-			 * EOS, so grab another frame
+		if (buf) {
+			/* this should only ever happen if the port is
+			 * disabled and there are buffers still queued
 			 */
+			vb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);
+			pr_debug("Empty buffer");
+		} else if (dev->capture.frame_count) {
+			/* grab another frame */
 			if (is_capturing(dev)) {
-				v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,
-					 "Grab another frame");
+				pr_debug("Grab another frame");
 				vchiq_mmal_port_parameter_set(
 					instance,
 					dev->capture.camera_port,
@@ -380,89 +354,72 @@
 					&dev->capture.frame_count,
 					sizeof(dev->capture.frame_count));
 			}
-			if (vchiq_mmal_submit_buffer(instance, port,
-						     &buf->mmal))
-				v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,
-					 "Failed to return EOS buffer");
 		} else {
-			/* stopping streaming.
-			 * return buffer, and signal frame completion
-			 */
-			vb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);
+			/* signal frame completion */
 			complete(&dev->capture.frame_cmplt);
 		}
-		return;
-	}
+	} else {
+		if (dev->capture.frame_count) {
+			if (dev->capture.vc_start_timestamp == -1) {
+				buf->vb.vb2_buf.timestamp = ktime_get_ns();
+				v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,
+					 "Buffer time set as current time - %lld",
+					 buf->vb.vb2_buf.timestamp);
 
-	if (!dev->capture.frame_count) {
-		/* signal frame completion */
-		vb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);
-		complete(&dev->capture.frame_cmplt);
-		return;
-	}
+			} else if (pts != 0) {
+				ktime_t timestamp;
+				s64 runtime_us = pts -
+				    dev->capture.vc_start_timestamp;
+				timestamp = ktime_add_us(dev->capture.kernel_start_ts,
+							 runtime_us);
+				v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,
+					 "Convert start time %llu and %llu with offset %llu to %llu\n",
+					 ktime_to_ns(dev->capture.kernel_start_ts),
+					 dev->capture.vc_start_timestamp, pts,
+					 ktime_to_ns(timestamp));
+				buf->vb.vb2_buf.timestamp = ktime_to_ns(timestamp);
+			} else {
+				if (dev->capture.last_timestamp) {
+					buf->vb.vb2_buf.timestamp =
+						dev->capture.last_timestamp;
+					v4l2_dbg(1, bcm2835_v4l2_debug,
+						 &dev->v4l2_dev,
+						 "Buffer time set as last timestamp - %lld",
+						 buf->vb.vb2_buf.timestamp);
+				} else {
+					buf->vb.vb2_buf.timestamp =
+						ktime_to_ns(dev->capture.kernel_start_ts);
+					v4l2_dbg(1, bcm2835_v4l2_debug,
+						 &dev->v4l2_dev,
+						 "Buffer time set as start timestamp - %lld",
+						 buf->vb.vb2_buf.timestamp);
+				}
+			}
+			dev->capture.last_timestamp = buf->vb.vb2_buf.timestamp;
 
-	if (dev->capture.vc_start_timestamp == -1) {
-		/*
-		 * VPU doesn't support MMAL_PARAMETER_SYSTEM_TIME, rely on
-		 * kernel time, and have no latency compensation.
-		 */
-		buf->vb.vb2_buf.timestamp = ktime_get_ns();
-		v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,
-			 "Buffer time set as current time - %lld",
-			 buf->vb.vb2_buf.timestamp);
-	} else if (mmal_buf->pts != 0) {
-		ktime_t timestamp;
-		s64 runtime_us = mmal_buf->pts -
-		    dev->capture.vc_start_timestamp;
-		timestamp = ktime_add_us(dev->capture.kernel_start_ts,
-					 runtime_us);
-		v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,
-			 "Convert start time %llu and %llu with offset %llu to %llu\n",
-			 ktime_to_ns(dev->capture.kernel_start_ts),
-			 dev->capture.vc_start_timestamp, mmal_buf->pts,
-			 ktime_to_ns(timestamp));
-		if (timestamp < dev->capture.last_timestamp) {
+			vb2_set_plane_payload(&buf->vb.vb2_buf, 0, length);
 			v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,
-				 "Negative delta - using last time\n");
-			timestamp = dev->capture.last_timestamp;
-		}
-		buf->vb.vb2_buf.timestamp = ktime_to_ns(timestamp);
-	} else {
-		if (dev->capture.last_timestamp) {
-			buf->vb.vb2_buf.timestamp = dev->capture.last_timestamp;
-			v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,
-				 "Buffer time set as last timestamp - %lld",
-				 buf->vb.vb2_buf.timestamp);
+				 "Buffer has ts %llu",
+				 dev->capture.last_timestamp);
+			vb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_DONE);
+
+			if (mmal_flags & MMAL_BUFFER_HEADER_FLAG_EOS &&
+			    is_capturing(dev)) {
+				v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,
+					 "Grab another frame as buffer has EOS");
+				vchiq_mmal_port_parameter_set(
+					instance,
+					dev->capture.camera_port,
+					MMAL_PARAMETER_CAPTURE,
+					&dev->capture.frame_count,
+					sizeof(dev->capture.frame_count));
+			}
 		} else {
-			buf->vb.vb2_buf.timestamp =
-				ktime_to_ns(dev->capture.kernel_start_ts);
-			v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,
-				 "Buffer time set as start timestamp - %lld",
-				 buf->vb.vb2_buf.timestamp);
+			/* signal frame completion */
+			vb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);
+			complete(&dev->capture.frame_cmplt);
 		}
 	}
-	dev->capture.last_timestamp = buf->vb.vb2_buf.timestamp;
-	buf->vb.sequence = dev->capture.sequence++;
-	buf->vb.field = V4L2_FIELD_NONE;
-
-	vb2_set_plane_payload(&buf->vb.vb2_buf, 0, mmal_buf->length);
-	if (mmal_buf->mmal_flags & MMAL_BUFFER_HEADER_FLAG_KEYFRAME)
-		buf->vb.flags |= V4L2_BUF_FLAG_KEYFRAME;
-
-	v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,
-		 "Buffer has ts %llu", dev->capture.last_timestamp);
-	vb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_DONE);
-
-	if (mmal_buf->mmal_flags & MMAL_BUFFER_HEADER_FLAG_EOS &&
-	    is_capturing(dev)) {
-		v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,
-			 "Grab another frame as buffer has EOS");
-		vchiq_mmal_port_parameter_set(instance,
-					      dev->capture.camera_port,
-					      MMAL_PARAMETER_CAPTURE,
-					      &dev->capture.frame_count,
-					      sizeof(dev->capture.frame_count));
-	}
 }
 
 static int enable_camera(struct bm2835_mmal_dev *dev)
@@ -472,7 +429,7 @@
 	if (!dev->camera_use_count) {
 		ret = vchiq_mmal_port_parameter_set(
 			dev->instance,
-			&dev->component[COMP_CAMERA]->control,
+			&dev->component[MMAL_COMPONENT_CAMERA]->control,
 			MMAL_PARAMETER_CAMERA_NUM, &dev->camera_num,
 			sizeof(dev->camera_num));
 		if (ret < 0) {
@@ -483,7 +440,7 @@
 
 		ret = vchiq_mmal_component_enable(
 				dev->instance,
-				dev->component[COMP_CAMERA]);
+				dev->component[MMAL_COMPONENT_CAMERA]);
 		if (ret < 0) {
 			v4l2_err(&dev->v4l2_dev,
 				 "Failed enabling camera, ret %d\n", ret);
@@ -515,7 +472,7 @@
 		ret =
 		    vchiq_mmal_component_disable(
 				dev->instance,
-				dev->component[COMP_CAMERA]);
+				dev->component[MMAL_COMPONENT_CAMERA]);
 		if (ret < 0) {
 			v4l2_err(&dev->v4l2_dev,
 				 "Failed disabling camera, ret %d\n", ret);
@@ -523,7 +480,7 @@
 		}
 		vchiq_mmal_port_parameter_set(
 			dev->instance,
-			&dev->component[COMP_CAMERA]->control,
+			&dev->component[MMAL_COMPONENT_CAMERA]->control,
 			MMAL_PARAMETER_CAMERA_NUM, &i,
 			sizeof(i));
 	}
@@ -536,16 +493,14 @@
 {
 	struct bm2835_mmal_dev *dev = vb2_get_drv_priv(vb->vb2_queue);
 	struct vb2_v4l2_buffer *vb2 = to_vb2_v4l2_buffer(vb);
-	struct vb2_mmal_buffer *buf =
-				container_of(vb2, struct vb2_mmal_buffer, vb);
+	struct mmal_buffer *buf = container_of(vb2, struct mmal_buffer, vb);
 	int ret;
 
 	v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,
 		 "%s: dev:%p buf:%p, idx %u\n",
 		 __func__, dev, buf, vb2->vb2_buf.index);
 
-	ret = vchiq_mmal_submit_buffer(dev->instance, dev->capture.port,
-				       &buf->mmal);
+	ret = vchiq_mmal_submit_buffer(dev->instance, dev->capture.port, buf);
 	if (ret < 0)
 		v4l2_err(&dev->v4l2_dev, "%s: error submitting buffer\n",
 			 __func__);
@@ -574,18 +529,15 @@
 	/* enable frame capture */
 	dev->capture.frame_count = 1;
 
-	/* reset sequence number */
-	dev->capture.sequence = 0;
-
 	/* if the preview is not already running, wait for a few frames for AGC
 	 * to settle down.
 	 */
-	if (!dev->component[COMP_PREVIEW]->enabled)
+	if (!dev->component[MMAL_COMPONENT_PREVIEW]->enabled)
 		msleep(300);
 
 	/* enable the connection from camera to encoder (if applicable) */
-	if (dev->capture.camera_port != dev->capture.port &&
-	    dev->capture.camera_port) {
+	if (dev->capture.camera_port != dev->capture.port
+	    && dev->capture.camera_port) {
 		ret = vchiq_mmal_port_enable(dev->instance,
 					     dev->capture.camera_port, NULL);
 		if (ret) {
@@ -608,11 +560,10 @@
 
 		/* Flag to indicate just to rely on kernel timestamps */
 		dev->capture.vc_start_timestamp = -1;
-	} else {
+	} else
 		v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,
 			 "Start time %lld size %d\n",
 			 dev->capture.vc_start_timestamp, parameter_size);
-	}
 
 	dev->capture.kernel_start_ts = ktime_get();
 	dev->capture.last_timestamp = 0;
@@ -623,8 +574,8 @@
 	    vchiq_mmal_port_enable(dev->instance, dev->capture.port, buffer_cb);
 	if (ret) {
 		v4l2_err(&dev->v4l2_dev,
-			 "Failed to enable capture port - error %d. Disabling camera port again\n",
-			 ret);
+			"Failed to enable capture port - error %d. Disabling camera port again\n",
+			ret);
 
 		vchiq_mmal_port_disable(dev->instance,
 					dev->capture.camera_port);
@@ -650,7 +601,6 @@
 	int ret;
 	unsigned long timeout;
 	struct bm2835_mmal_dev *dev = vb2_get_drv_priv(vq);
-	struct vchiq_mmal_port *port = dev->capture.port;
 
 	v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev, "%s: dev:%p\n",
 		 __func__, dev);
@@ -659,7 +609,7 @@
 	dev->capture.frame_count = 0;
 
 	/* ensure a format has actually been set */
-	if (!port) {
+	if (!dev->capture.port) {
 		v4l2_err(&dev->v4l2_dev,
 			 "no capture port - stream not started?\n");
 		return;
@@ -674,35 +624,26 @@
 				      &dev->capture.frame_count,
 				      sizeof(dev->capture.frame_count));
 
+	/* wait for last frame to complete */
+	timeout = wait_for_completion_timeout(&dev->capture.frame_cmplt, HZ);
+	if (timeout == 0)
+		v4l2_err(&dev->v4l2_dev,
+			 "timed out waiting for frame completion\n");
+
 	v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,
 		 "disabling connection\n");
 
 	/* disable the connection from camera to encoder */
 	ret = vchiq_mmal_port_disable(dev->instance, dev->capture.camera_port);
-	if (!ret && dev->capture.camera_port != port) {
+	if (!ret && dev->capture.camera_port != dev->capture.port) {
 		v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,
 			 "disabling port\n");
-		ret = vchiq_mmal_port_disable(dev->instance, port);
-	} else if (dev->capture.camera_port != port) {
+		ret = vchiq_mmal_port_disable(dev->instance, dev->capture.port);
+	} else if (dev->capture.camera_port != dev->capture.port) {
 		v4l2_err(&dev->v4l2_dev, "port_disable failed, error %d\n",
 			 ret);
 	}
 
-	/* wait for all buffers to be returned */
-	while (atomic_read(&port->buffers_with_vpu)) {
-		v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,
-			 "%s: Waiting for buffers to be returned - %d outstanding\n",
-			 __func__, atomic_read(&port->buffers_with_vpu));
-		timeout = wait_for_completion_timeout(&dev->capture.frame_cmplt,
-						      HZ);
-		if (timeout == 0) {
-			v4l2_err(&dev->v4l2_dev, "%s: Timeout waiting for buffers to be returned - %d outstanding\n",
-				 __func__,
-				 atomic_read(&port->buffers_with_vpu));
-			break;
-		}
-	}
-
 	if (disable_camera(dev) < 0)
 		v4l2_err(&dev->v4l2_dev, "Failed to disable camera\n");
 }
@@ -814,9 +755,9 @@
 	vidioc_try_fmt_vid_overlay(file, priv, f);
 
 	dev->overlay = f->fmt.win;
-	if (dev->component[COMP_PREVIEW]->enabled) {
+	if (dev->component[MMAL_COMPONENT_PREVIEW]->enabled) {
 		set_overlay_params(dev,
-				   &dev->component[COMP_PREVIEW]->input[0]);
+				   &dev->component[MMAL_COMPONENT_PREVIEW]->input[0]);
 	}
 
 	return 0;
@@ -829,12 +770,13 @@
 	struct vchiq_mmal_port *src;
 	struct vchiq_mmal_port *dst;
 
-	if ((on && dev->component[COMP_PREVIEW]->enabled) ||
-	    (!on && !dev->component[COMP_PREVIEW]->enabled))
+	if ((on && dev->component[MMAL_COMPONENT_PREVIEW]->enabled) ||
+	    (!on && !dev->component[MMAL_COMPONENT_PREVIEW]->enabled))
 		return 0;	/* already in requested state */
 
 	src =
-	    &dev->component[COMP_CAMERA]->output[CAM_PORT_PREVIEW];
+	    &dev->component[MMAL_COMPONENT_CAMERA]->
+	    output[MMAL_CAMERA_PORT_PREVIEW];
 
 	if (!on) {
 		/* disconnect preview ports and disable component */
@@ -846,40 +788,38 @@
 		if (ret >= 0)
 			ret = vchiq_mmal_component_disable(
 					dev->instance,
-					dev->component[COMP_PREVIEW]);
+					dev->component[MMAL_COMPONENT_PREVIEW]);
 
 		disable_camera(dev);
 		return ret;
 	}
 
 	/* set preview port format and connect it to output */
-	dst = &dev->component[COMP_PREVIEW]->input[0];
+	dst = &dev->component[MMAL_COMPONENT_PREVIEW]->input[0];
 
 	ret = vchiq_mmal_port_set_format(dev->instance, src);
 	if (ret < 0)
-		return ret;
+		goto error;
 
 	ret = set_overlay_params(dev, dst);
 	if (ret < 0)
-		return ret;
+		goto error;
 
-	if (enable_camera(dev) < 0) {
-		ret = -EINVAL;
-		return ret;
-	}
+	if (enable_camera(dev) < 0)
+		goto error;
 
 	ret = vchiq_mmal_component_enable(
 			dev->instance,
-			dev->component[COMP_PREVIEW]);
+			dev->component[MMAL_COMPONENT_PREVIEW]);
 	if (ret < 0)
-		return ret;
+		goto error;
 
 	v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev, "connecting %p to %p\n",
 		 src, dst);
 	ret = vchiq_mmal_port_connect_tunnel(dev->instance, src, dst);
 	if (!ret)
 		ret = vchiq_mmal_port_enable(dev->instance, src, NULL);
-
+error:
 	return ret;
 }
 
@@ -891,7 +831,8 @@
 	 */
 	struct bm2835_mmal_dev *dev = video_drvdata(file);
 	struct vchiq_mmal_port *preview_port =
-		&dev->component[COMP_CAMERA]->output[CAM_PORT_PREVIEW];
+		    &dev->component[MMAL_COMPONENT_CAMERA]->
+		    output[MMAL_CAMERA_PORT_PREVIEW];
 
 	a->capability = V4L2_FBUF_CAP_EXTERNOVERLAY |
 			V4L2_FBUF_CAP_GLOBAL_ALPHA;
@@ -1025,27 +966,14 @@
 			      1, 0);
 	f->fmt.pix.bytesperline = f->fmt.pix.width * mfmt->ybbp;
 	if (!mfmt->remove_padding) {
-		if (mfmt->depth == 24) {
-			/*
-			 * 24bpp is a pain as we can't use simple masking.
-			 * Min stride is width aligned to 16, times 24bpp.
-			 */
-			f->fmt.pix.bytesperline =
-				((f->fmt.pix.width + 15) & ~15) * 3;
-		} else {
-			/*
-			 * GPU isn't removing padding, so stride is aligned to
-			 * 32
-			 */
-			int align_mask = ((32 * mfmt->depth) >> 3) - 1;
-
-			f->fmt.pix.bytesperline =
-				(f->fmt.pix.bytesperline + align_mask) &
-							~align_mask;
-		}
+		int align_mask = ((32 * mfmt->depth) >> 3) - 1;
+		/* GPU isn't removing padding, so stride is aligned to 32 */
+		f->fmt.pix.bytesperline =
+			(f->fmt.pix.bytesperline + align_mask) & ~align_mask;
 		v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,
-			 "Not removing padding, so bytes/line = %d\n",
-			 f->fmt.pix.bytesperline);
+			 "Not removing padding, so bytes/line = %d, "
+			 "(align_mask %d)\n",
+			 f->fmt.pix.bytesperline, align_mask);
 	}
 
 	/* Image buffer has to be padded to allow for alignment, even though
@@ -1096,7 +1024,8 @@
 					       dev->capture.camera_port, NULL);
 		dev->capture.camera_port = NULL;
 		ret = vchiq_mmal_component_disable(dev->instance,
-						   dev->capture.encode_component);
+						   dev->capture.
+						   encode_component);
 		if (ret)
 			v4l2_err(&dev->v4l2_dev,
 				 "Failed to disable encode component %d\n",
@@ -1106,28 +1035,31 @@
 	}
 	/* format dependent port setup */
 	switch (mfmt->mmal_component) {
-	case COMP_CAMERA:
+	case MMAL_COMPONENT_CAMERA:
 		/* Make a further decision on port based on resolution */
-		if (f->fmt.pix.width <= max_video_width &&
-		    f->fmt.pix.height <= max_video_height)
-			camera_port =
-			    &dev->component[COMP_CAMERA]->output[CAM_PORT_VIDEO];
+		if (f->fmt.pix.width <= max_video_width
+		    && f->fmt.pix.height <= max_video_height)
+			camera_port = port =
+			    &dev->component[MMAL_COMPONENT_CAMERA]->
+			    output[MMAL_CAMERA_PORT_VIDEO];
 		else
-			camera_port =
-			    &dev->component[COMP_CAMERA]->output[CAM_PORT_CAPTURE];
-		port = camera_port;
+			camera_port = port =
+			    &dev->component[MMAL_COMPONENT_CAMERA]->
+			    output[MMAL_CAMERA_PORT_CAPTURE];
 		break;
-	case COMP_IMAGE_ENCODE:
-		encode_component = dev->component[COMP_IMAGE_ENCODE];
-		port = &dev->component[COMP_IMAGE_ENCODE]->output[0];
+	case MMAL_COMPONENT_IMAGE_ENCODE:
+		encode_component = dev->component[MMAL_COMPONENT_IMAGE_ENCODE];
+		port = &dev->component[MMAL_COMPONENT_IMAGE_ENCODE]->output[0];
 		camera_port =
-		    &dev->component[COMP_CAMERA]->output[CAM_PORT_CAPTURE];
+		    &dev->component[MMAL_COMPONENT_CAMERA]->
+		    output[MMAL_CAMERA_PORT_CAPTURE];
 		break;
-	case COMP_VIDEO_ENCODE:
-		encode_component = dev->component[COMP_VIDEO_ENCODE];
-		port = &dev->component[COMP_VIDEO_ENCODE]->output[0];
+	case MMAL_COMPONENT_VIDEO_ENCODE:
+		encode_component = dev->component[MMAL_COMPONENT_VIDEO_ENCODE];
+		port = &dev->component[MMAL_COMPONENT_VIDEO_ENCODE]->output[0];
 		camera_port =
-		    &dev->component[COMP_CAMERA]->output[CAM_PORT_VIDEO];
+		    &dev->component[MMAL_COMPONENT_CAMERA]->
+		    output[MMAL_CAMERA_PORT_VIDEO];
 		break;
 	default:
 		break;
@@ -1167,13 +1099,15 @@
 
 	ret = vchiq_mmal_port_set_format(dev->instance, camera_port);
 
-	if (!ret &&
-	    camera_port ==
-	    &dev->component[COMP_CAMERA]->output[CAM_PORT_VIDEO]) {
+	if (!ret
+	    && camera_port ==
+	    &dev->component[MMAL_COMPONENT_CAMERA]->
+	    output[MMAL_CAMERA_PORT_VIDEO]) {
 		bool overlay_enabled =
-		    !!dev->component[COMP_PREVIEW]->enabled;
+		    !!dev->component[MMAL_COMPONENT_PREVIEW]->enabled;
 		struct vchiq_mmal_port *preview_port =
-		    &dev->component[COMP_CAMERA]->output[CAM_PORT_PREVIEW];
+		    &dev->component[MMAL_COMPONENT_CAMERA]->
+		    output[MMAL_CAMERA_PORT_PREVIEW];
 		/* Preview and encode ports need to match on resolution */
 		if (overlay_enabled) {
 			/* Need to disable the overlay before we can update
@@ -1204,7 +1138,7 @@
 			ret = vchiq_mmal_port_connect_tunnel(
 				dev->instance,
 				preview_port,
-				&dev->component[COMP_PREVIEW]->input[0]);
+				&dev->component[MMAL_COMPONENT_PREVIEW]->input[0]);
 			if (!ret)
 				ret = vchiq_mmal_port_enable(dev->instance,
 							     preview_port,
@@ -1258,11 +1192,11 @@
 				port->format.encoding_variant = 0;
 				/* Set any encoding specific parameters */
 				switch (mfmt->mmal_component) {
-				case COMP_VIDEO_ENCODE:
+				case MMAL_COMPONENT_VIDEO_ENCODE:
 					port->format.bitrate =
 					    dev->capture.encode_bitrate;
 					break;
-				case COMP_IMAGE_ENCODE:
+				case MMAL_COMPONENT_IMAGE_ENCODE:
 					/* Could set EXIF parameters here */
 					break;
 				default:
@@ -1306,8 +1240,9 @@
 						 port->current_buffer.size);
 					port->current_buffer.size =
 					    (f->fmt.pix.sizeimage <
-					     (100 << 10)) ?
-					    (100 << 10) : f->fmt.pix.sizeimage;
+					     (100 << 10))
+					    ? (100 << 10)
+					    : f->fmt.pix.sizeimage;
 				}
 				v4l2_dbg(1, bcm2835_v4l2_debug,
 					 &dev->v4l2_dev,
@@ -1391,7 +1326,7 @@
 }
 
 static int vidioc_enum_framesizes(struct file *file, void *fh,
-				  struct v4l2_frmsizeenum *fsize)
+			   struct v4l2_frmsizeenum *fsize)
 {
 	struct bm2835_mmal_dev *dev = video_drvdata(file);
 	static const struct v4l2_frmsize_stepwise sizes = {
@@ -1636,14 +1571,14 @@
 
 	/* get the camera component ready */
 	ret = vchiq_mmal_component_init(dev->instance, "ril.camera",
-					&dev->component[COMP_CAMERA]);
+					&dev->component[MMAL_COMPONENT_CAMERA]);
 	if (ret < 0)
 		goto unreg_mmal;
 
-	camera = dev->component[COMP_CAMERA];
-	if (camera->outputs < CAM_PORT_COUNT) {
+	camera = dev->component[MMAL_COMPONENT_CAMERA];
+	if (camera->outputs < MMAL_CAMERA_PORT_COUNT) {
 		v4l2_err(&dev->v4l2_dev, "%s: too few camera outputs %d needed %d\n",
-			 __func__, camera->outputs, CAM_PORT_COUNT);
+			 __func__, camera->outputs, MMAL_CAMERA_PORT_COUNT);
 		ret = -EINVAL;
 		goto unreg_camera;
 	}
@@ -1665,7 +1600,7 @@
 	dev->rgb_bgr_swapped = true;
 	param_size = sizeof(supported_encodings);
 	ret = vchiq_mmal_port_parameter_get(dev->instance,
-					    &camera->output[CAM_PORT_CAPTURE],
+					    &camera->output[MMAL_CAMERA_PORT_CAPTURE],
 					    MMAL_PARAMETER_SUPPORTED_ENCODINGS,
 					    &supported_encodings,
 					    &param_size);
@@ -1686,7 +1621,7 @@
 			}
 		}
 	}
-	format = &camera->output[CAM_PORT_PREVIEW].format;
+	format = &camera->output[MMAL_CAMERA_PORT_PREVIEW].format;
 
 	format->encoding = MMAL_ENCODING_OPAQUE;
 	format->encoding_variant = MMAL_ENCODING_I420;
@@ -1700,7 +1635,7 @@
 	format->es->video.frame_rate.num = 0; /* Rely on fps_range */
 	format->es->video.frame_rate.den = 1;
 
-	format = &camera->output[CAM_PORT_VIDEO].format;
+	format = &camera->output[MMAL_CAMERA_PORT_VIDEO].format;
 
 	format->encoding = MMAL_ENCODING_OPAQUE;
 	format->encoding_variant = MMAL_ENCODING_I420;
@@ -1714,7 +1649,7 @@
 	format->es->video.frame_rate.num = 0; /* Rely on fps_range */
 	format->es->video.frame_rate.den = 1;
 
-	format = &camera->output[CAM_PORT_CAPTURE].format;
+	format = &camera->output[MMAL_CAMERA_PORT_CAPTURE].format;
 
 	format->encoding = MMAL_ENCODING_OPAQUE;
 
@@ -1738,49 +1673,50 @@
 	/* get the preview component ready */
 	ret = vchiq_mmal_component_init(
 			dev->instance, "ril.video_render",
-			&dev->component[COMP_PREVIEW]);
+			&dev->component[MMAL_COMPONENT_PREVIEW]);
 	if (ret < 0)
 		goto unreg_camera;
 
-	if (dev->component[COMP_PREVIEW]->inputs < 1) {
+	if (dev->component[MMAL_COMPONENT_PREVIEW]->inputs < 1) {
 		ret = -EINVAL;
 		v4l2_err(&dev->v4l2_dev, "%s: too few input ports %d needed %d\n",
-			 __func__, dev->component[COMP_PREVIEW]->inputs, 1);
+			 __func__, dev->component[MMAL_COMPONENT_PREVIEW]->inputs, 1);
 		goto unreg_preview;
 	}
 
 	/* get the image encoder component ready */
 	ret = vchiq_mmal_component_init(
 		dev->instance, "ril.image_encode",
-		&dev->component[COMP_IMAGE_ENCODE]);
+		&dev->component[MMAL_COMPONENT_IMAGE_ENCODE]);
 	if (ret < 0)
 		goto unreg_preview;
 
-	if (dev->component[COMP_IMAGE_ENCODE]->inputs < 1) {
+	if (dev->component[MMAL_COMPONENT_IMAGE_ENCODE]->inputs < 1) {
 		ret = -EINVAL;
 		v4l2_err(&dev->v4l2_dev, "%s: too few input ports %d needed %d\n",
-			 __func__, dev->component[COMP_IMAGE_ENCODE]->inputs,
+			 __func__, dev->component[MMAL_COMPONENT_IMAGE_ENCODE]->inputs,
 			 1);
 		goto unreg_image_encoder;
 	}
 
 	/* get the video encoder component ready */
 	ret = vchiq_mmal_component_init(dev->instance, "ril.video_encode",
-					&dev->component[COMP_VIDEO_ENCODE]);
+					&dev->
+					component[MMAL_COMPONENT_VIDEO_ENCODE]);
 	if (ret < 0)
 		goto unreg_image_encoder;
 
-	if (dev->component[COMP_VIDEO_ENCODE]->inputs < 1) {
+	if (dev->component[MMAL_COMPONENT_VIDEO_ENCODE]->inputs < 1) {
 		ret = -EINVAL;
 		v4l2_err(&dev->v4l2_dev, "%s: too few input ports %d needed %d\n",
-			 __func__, dev->component[COMP_VIDEO_ENCODE]->inputs,
+			 __func__, dev->component[MMAL_COMPONENT_VIDEO_ENCODE]->inputs,
 			 1);
 		goto unreg_vid_encoder;
 	}
 
 	{
 		struct vchiq_mmal_port *encoder_port =
-			&dev->component[COMP_VIDEO_ENCODE]->output[0];
+			&dev->component[MMAL_COMPONENT_VIDEO_ENCODE]->output[0];
 		encoder_port->format.encoding = MMAL_ENCODING_H264;
 		ret = vchiq_mmal_port_set_format(dev->instance,
 						 encoder_port);
@@ -1791,12 +1727,12 @@
 
 		vchiq_mmal_port_parameter_set(
 			dev->instance,
-			&dev->component[COMP_VIDEO_ENCODE]->control,
+			&dev->component[MMAL_COMPONENT_VIDEO_ENCODE]->control,
 			MMAL_PARAMETER_VIDEO_IMMUTABLE_INPUT,
 			&enable, sizeof(enable));
 
 		vchiq_mmal_port_parameter_set(dev->instance,
-					      &dev->component[COMP_VIDEO_ENCODE]->control,
+					      &dev->component[MMAL_COMPONENT_VIDEO_ENCODE]->control,
 					      MMAL_PARAMETER_MINIMISE_FRAGMENTATION,
 					      &enable,
 					      sizeof(enable));
@@ -1814,23 +1750,23 @@
 	pr_err("Cleanup: Destroy video encoder\n");
 	vchiq_mmal_component_finalise(
 		dev->instance,
-		dev->component[COMP_VIDEO_ENCODE]);
+		dev->component[MMAL_COMPONENT_VIDEO_ENCODE]);
 
 unreg_image_encoder:
 	pr_err("Cleanup: Destroy image encoder\n");
 	vchiq_mmal_component_finalise(
 		dev->instance,
-		dev->component[COMP_IMAGE_ENCODE]);
+		dev->component[MMAL_COMPONENT_IMAGE_ENCODE]);
 
 unreg_preview:
 	pr_err("Cleanup: Destroy video render\n");
 	vchiq_mmal_component_finalise(dev->instance,
-				      dev->component[COMP_PREVIEW]);
+				      dev->component[MMAL_COMPONENT_PREVIEW]);
 
 unreg_camera:
 	pr_err("Cleanup: Destroy camera\n");
 	vchiq_mmal_component_finalise(dev->instance,
-				      dev->component[COMP_CAMERA]);
+				      dev->component[MMAL_COMPONENT_CAMERA]);
 
 unreg_mmal:
 	vchiq_mmal_finalise(dev->instance);
@@ -1886,19 +1822,21 @@
 					     dev->capture.encode_component);
 	}
 	vchiq_mmal_component_disable(dev->instance,
-				     dev->component[COMP_CAMERA]);
+				     dev->component[MMAL_COMPONENT_CAMERA]);
 
 	vchiq_mmal_component_finalise(dev->instance,
-				      dev->component[COMP_VIDEO_ENCODE]);
+				      dev->
+				      component[MMAL_COMPONENT_VIDEO_ENCODE]);
 
 	vchiq_mmal_component_finalise(dev->instance,
-				      dev->component[COMP_IMAGE_ENCODE]);
+				      dev->
+				      component[MMAL_COMPONENT_IMAGE_ENCODE]);
 
 	vchiq_mmal_component_finalise(dev->instance,
-				      dev->component[COMP_PREVIEW]);
+				      dev->component[MMAL_COMPONENT_PREVIEW]);
 
 	vchiq_mmal_component_finalise(dev->instance,
-				      dev->component[COMP_CAMERA]);
+				      dev->component[MMAL_COMPONENT_CAMERA]);
 
 	v4l2_ctrl_handler_free(&dev->ctrl_handler);
 
@@ -1999,7 +1937,7 @@
 		q->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
 		q->io_modes = VB2_MMAP | VB2_USERPTR | VB2_READ;
 		q->drv_priv = dev;
-		q->buf_struct_size = sizeof(struct vb2_mmal_buffer);
+		q->buf_struct_size = sizeof(struct mmal_buffer);
 		q->ops = &bm2835_mmal_video_qops;
 		q->mem_ops = &vb2_vmalloc_memops;
 		q->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;
