commit 46ed4f4fa1cf98b3da433f76ca4c7ac33f45d423
Author: Long Li <longli@microsoft.com>
Date:   Fri Nov 2 18:02:48 2018 +0000

    genirq/affinity: Spread IRQs to all available NUMA nodes
    
    [ Upstream commit b82592199032bf7c778f861b936287e37ebc9f62 ]
    
    If the number of NUMA nodes exceeds the number of MSI/MSI-X interrupts
    which are allocated for a device, the interrupt affinity spreading code
    fails to spread them across all nodes.
    
    The reason is, that the spreading code starts from node 0 and continues up
    to the number of interrupts requested for allocation. This leaves the nodes
    past the last interrupt unused.
    
    This results in interrupt concentration on the first nodes which violates
    the assumption of the block layer that all nodes are covered evenly. As a
    consequence the NUMA nodes above the number of interrupts are all assigned
    to hardware queue 0 and therefore NUMA node 0, which results in bad
    performance and has CPU hotplug implications, because queue 0 gets shut
    down when the last CPU of node 0 is offlined.
    
    Go over all NUMA nodes and assign them round-robin to all requested
    interrupts to solve this.
    
    [ tglx: Massaged changelog ]
    
    Signed-off-by: Long Li <longli@microsoft.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ming Lei <ming.lei@redhat.com>
    Cc: Michael Kelley <mikelley@microsoft.com>
    Link: https://lkml.kernel.org/r/20181102180248.13583-1-longli@linuxonhyperv.com
    Signed-off-by: Sasha Levin <sashal@kernel.org>

diff --git a/kernel/irq/affinity.c b/kernel/irq/affinity.c
index f4f29b9d90ee..e12cdf637c71 100644
--- a/kernel/irq/affinity.c
+++ b/kernel/irq/affinity.c
@@ -117,12 +117,11 @@ static int irq_build_affinity_masks(const struct irq_affinity *affd,
 	 */
 	if (numvecs <= nodes) {
 		for_each_node_mask(n, nodemsk) {
-			cpumask_copy(masks + curvec, node_to_cpumask[n]);
-			if (++done == numvecs)
-				break;
+			cpumask_or(masks + curvec, masks + curvec, node_to_cpumask[n]);
 			if (++curvec == last_affv)
 				curvec = affd->pre_vectors;
 		}
+		done = numvecs;
 		goto out;
 	}
 
diff -uN a/1.txt b/1.txt
--- a/dummy/rpi_1008_46ed4f4fa1cf98b3da433f76ca4c7ac33f45d423.txt	1970-01-01 00:00:00.000000000 +0000
+++ b/dummy/rpi_1008_46ed4f4fa1cf98b3da433f76ca4c7ac33f45d423.txt	2013-12-23 04:07:40.000000000 +0000
@@ -0,0 +1 @@
+dummy file to ensure patch has content.
